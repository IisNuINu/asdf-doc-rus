<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf8">
<style language="css" content="text/css">
<!--
h1   { font-size: 14pt; font-weight: bold; }
h2   { font-size: 14pt; font-weight: bold; }
h3   { font-size: 12pt; font-weight: bold; }
body { font-size: 12pt; font-weight: normal; }
pre  { font-size: 10pt; }
tt   { font-size: 10pt; }
code { font-size: 10pt; }
-->
</style>
<title>``Описание Больших Систем(The Description of Large Systems)'' 
by Kent Pitman (September 1984)</title>
<meta http-equiv="keywords" content="Compilation, Large Systems, Lisp, System Maintenance">
<meta http-equiv="author" content="Kent M. Pitman">
<meta name="robots" content="index, nofollow">
</head>
<body vlink="#7700bb" text="#440077" link="#7700bb" bgcolor="#eeeeff" alink="#ff0000">

<font color="green">

<h1 align="center">Описание Больших Систем</h1>

<p align="center">
<b>This paper was published in hardcopy as<br>
MIT AI Memo 801<br>
September, 1984
</b>
</p>

<p>
 The substance of the original text appears in normal fonting,
 though a small number of out-and-out typos were corrected.
 Oddities of spelling that were the custom of the time
 (either generally, or just for me) were left alone.
 Some formatting of headings and tables was adjusted slightly for HTML.
 Any new text that has been added appears
 bracketed and in color green; such text is intended to
 help clarify the historical context, since considerable time 
 passed between the time this paper was published and the time I 
 converted it to HTML.
</p>

<p>
Чтобы избежать путаницы с пакетом Common Lisp <tt>SYSTEM</tt>,
Я изменил все ссылки из пакета <tt>SYSTEM</tt> на ссылки пакета <tt>SYSDEF</tt>.
Такие ссылки выделены зеленым цветом, чтобы напомнить читателю, что оригинальный
документ отличается в данном месте.
</p>

<p>
Special thanks to <a href="mailto:amoroso@mclink.it">Paolo Amoroso</a>
for helping to reconstruct this document by typing in its text anew from
the hardcopy, since its original source is believed to have been lost.
He also provided much useful help in reviewing my notes and code updates.
<br>
--<a href="http://www.nhplace.com/kent/contact-kent.html"><i>Kent Pitman</i></a>, 23-Jan-2001
</p>

<p align="center">
<a href="#original-start">Annotated original document follows.</a><br>
<a href="http://www.nhplace.com/kent/Papers/index.html"><i>Click here for an index 
of other titles by Kent Pitman.</i></a>
</p>

</font>

<hr>

<table width="100%">
<tbody><tr>
<td colspan="2" align="center">
Massachusetts Institute of Technology<br>
Artificial Intelligence Laboratory
</td>
</tr>
<tr>
<td valign="top" align="left">
A.I. Memo No. 801
</td>
<td valign="top" align="right">
September, 1984
</td>
</tr>
</tbody></table>

<a name="original-start"><h1 align="center">Описание Больших Систем</h1></a>

<p align="center"><b>Kent M. Pitman</b></p>

<h2 align="center"><i>Аннотация</i></h2>

<p>
В этой статье мы обсуждаем проблемы, связанные с описанием и манипулированием
большими системами, когда их исходный код не содержится в одном файле.  Мы покажем,
почему и как развивались инструменты для решения этих проблем, такие как
<a name="footref1a">Unix</a><a href="#footnote1">[1]</a> <tt>MAKE</tt> и 
Lisp Machine <code>DEFSYSTEM</code>.
</p>

<p>
Существующие формализмы страдают от проблемы, заключающейся в том, что их
синтаксис нелегко отделить от их функциональности.  В языках программирования
существуют стандартные "соглашения о вызовах(calling conventions)", чтобы 
изолировать(отделить) вызывающую функцию от синтаксических деталей того, как
эта функция была определена, но до сих пор не существует таких соглашений, которые
бы скрыли от пользователей программных систем детали того, как эти системы
были описаны(определены).
</p>

<p>
Мы предлагаем низкоуровневую абстракцию данных, которая может поддерживать нотации,
такие как <tt>MAKE</tt> и <code>DEFSYSTEM</code>, не требуя, чтобы введение новой
нотации сопровождалось совершенно другим набором инструментов для создания экземпляров
или иного манипулирования получающейся системой.
</p>

<p>
Lisp используется для презентации, но проблемы не являются касающимися только
Lisp.
</p>

<hr width="20%" align="left">

<p>
Keywords: Compilation, Large Systems, Lisp, System Maintenance.
</p>

<hr width="20%" align="left">

<font size="3">
<div class="footnote">
<p>
This report describes research done at the Artificial Intelligence
Laboratory of the Massachusetts Institute of Technology. Support for the
laboratory's artificial intelligence research has been provided in part by
the Advanced Research Projects Agency of the Department of Defense under
Office of Naval Research contract N00014-80-C0505, in part by National
Science Foundation grants MCS-7912179 and MCS-8117633, and in part by the
IBM Corporation.
</p>

<p>
The views and conclusions contained in this document are those of the
authors and should not be interpreted as representing the policies,
expressed or implied, of the Department of Defense, of the National Science
Foundation, or of the IBM Corporation.
</p>

<p align="center">
© Massachusetts Institute of Technology, 1984<br>
</p>
</div>
</font>

<hr width="50%" align="center">

<h2>I. Введение</h2>

<p>
Из соображения модульности и удобства редактирования исходный код для больших
программных систем редко храниться в одном файле.  Вместо этого он обычно разбивается
на несколько небольших файлов, которые все вместе составляют единую систему.
</p>

<p>
Поскольку системные инструменты, такие как редакторы, компиляторы, загрузчики и
притнеры, как правило предназначены для работы с файлами, а не с системами,
обычно требуется какой-то дополнительный механизм, чтобы позволить их пользователям
иметь дело с системами, которые охватывают несколько файлов. В следующем разделе
мы проследим эволюцию инструментов для построения системы, выявив важные проблемы,
которые пытались решить ранние инструменты.
</p>

<p>
Затем мы представим обзор двух языков спецификации(описания) систем, 
<a name="footref1b">Unix</a><a href="#footnote1">[1]</a> <tt>MAKE</tt> и 
Lisp Machine <code>DEFSYSTEM</code>, которые иллюстрируют уровень технлогий,
доступных в настоящее время(1984 год) программистам для решения этих проблем.
Большинство критических замечаний, которые могут быть сделаны в отношении
существующих инструментов, находятся на синтаксическом уровне.  Инструменты
решают правильные проблемы, но их синтаксис может быть камнем преткновения,
препятствющим выражению определенных видов отношений и возможности расширять
первоначальную функциональность инструментов. Невозомжно изменить синтаксис
без переписывания большей части или всей основы инструмента поддержки .
</p>

<p>
В заключении мы предлагаем организационную стратегию, которая разделяет синтаксис
и функциональность.  Это позволяет программисту разрабатывать альтернативные 
иструменты обслуживания системы, не переопределяя каждый аспект оригинальных
инструментов.
</p>

<p>
Чтобы сделать обсуждение более конкретным, мы приведем несколько примеров
языков спецификаций, которые могут быть построены в рамках предлагаемой
конструкции. Тем не менее, важно понимать, что целью этой статьи не является
аргументация в пользу какой-либо конкретной записи. Скорее мы хотим проилюстрировать,
что предлагаемая нами организационная стратегия устанавливает подходящую
конструкцию для разработки альтернативных обозначений, подобных этим.  
В качестве <a href="#appendix-b">приложения</a>,
мы предлагаем пример реализации этих языков спецификаций в <tt>Lisp Machine Lisp</tt>,
чтобы дополнительно прояснить любые проблемы, оставшиеся не освещенными примерами,
использованными в основной части статьи.
</p>

<h2>II. Предпосылки(происхождение)</h2>

<p>
Существует ряд стандартных операций обслуживания систем. Эти операции включают
(но не ограничиваются ими) создание распечаток, копирование или переименование
файлов, составляющих исходный код системы, загрузку не скомпилированных исходных
файлов (например в интерпретатор  lisp), и компиляция изменённых файлов.
</p>

<p>
Для системы, поддерживаемой в виде единого монолитного файла, достаточно очевидно,
как можно выполнить большинство этих операций обслуживания.  Получить печатную
копию исходного кода системы, так же просто как получить бумажную копию любого
другого файла; Компилировать систему так же просто, как компилировать любой простой
файл.
</p>

<p>
Для более сложной системы, где исходный код распределен по нескольким
файлам, выполнение этих операций может быть значительно более сложным.
В этом случае, чтобы получить печатную копию системы, нужно попросить
распечатать каждый из исходных файлов.  Чтобы скомпилировать систему,
необходимо попросить скомпилировать каждый из исходных файлов и,
в некоторых случаях, чтобы компиляция проходила в определенном порядке.
Загрузка системы может быть аналогично сложной из-за другого( не обязательно
того же самого) набора ограничений на порядок выполнения.
</p>

<h3>Потребность в абстракции</h3>

<p>
Раньше считалось, что работа с системой разбитой на несоклько файлов означает,
необходимость запомнить все имена файлов и манипулировать каждым из них как отдельным
объектом. Среды программирования имели некоторое примитивное понимание файлов и
операций, которые должны выполняться над файлами, но не имели четкого понимания того,
что группы файлов могут работать вместе как единое целое.
</p>

<p>
Тогда(и до сих пор это было обычной практикой) создавали пакетые файлы,
содержащие команды, необходимые для выполнения определенных манипуляций.
Например, программист мог хранить файл, содержащий код для компиляции и
загрузки конкретной системы, и другой файл, содержащий код для
печати её исходного кода:
</p>

<table width="80%" border="1">
<tbody><tr><td>
<pre>
 ;; Batch sequence to compile/load system.
 (LOAD (COMPILE-FILE "MACROS.LISP"))
 (LOAD (COMPILE-FILE "UTILITY.LISP"))
 (LOAD (COMPILE-FILE "MAIN.LISP"))
</pre>
</td></tr>
</tbody><caption align="bottom"><tt>COMPILE-AND-LOAD-MYSYS.LISP</tt></caption>
</table>

<table width="80%" border="1">
<tbody><tr><td>
<pre> 

 ;; Batch sequence to hardcopy system sources.
 (HARDCOPY-FILE "MACROS.LISP")
 (HARDCOPY-FILE "UTILITY.LISP")
 (HARDCOPY-FILE "MAIN.LISP").
</pre>
</td></tr>
</tbody><caption align="bottom"><tt>HARDCOPY-MYSYS.LISP</tt></caption>
</table>

<p>
Распространенным, хотя возможно и довольно неуклюжим, было манипулирование
системами через такие командный файлы.  Это означало, что каждый раз, когда
вносились изменения в систему, все соответствующие командные файлы должны
были обновляться. Если не обновлять тщательно и полностью, пакетные файлы
могут легко стать непоследовательными, что приведет к запутанным последствиям.
Кроме того, поскольку информация о структуре системы была встроена процедурно,
единственный способ написать утилиту для применения к системе - это создать
еще один, отдельно сопровождаемый(поддерживаемый), пакетный файл.
</p>

<p>
Неудивительно, что программисты отошли от этого пакетного метода обслуживания
своих систем и пришли к идее, что система должна определяться абстрактно в 
каком-то центральном месте, а затем обрабатываться как единое целое, а не как
набор несвязанных отдельных компонентов(файлов).
</p>

<h3>Первое приближение</h3>

<p>
Вот пример кода, необходимого для реализации того  инструмента, который
мы обсуждаем:
</p>

<pre> (DEFVAR *SOURCE-INFO* (MAKE-PLIST))

 (DEFUN SYSTEM-SOURCES (SYSTEM) (GET *SOURCE-INFO* SYSTEM))

 (DEFUN DEFINE-SYSTEM-SOURCES (SYSTEM &amp;REST SOURCES)
   (PUTPROP *SOURCE-INFO* (COPYLIST SOURCES) SYSTEM))

 (DEFUN HARDCOPY-SYSTEM (SYSTEM)
   (MAPC #'HARDCOPY-FILE (SYSTEM-SOURCES SYSTEM)))

 (DEFUN COMPILE-AND-LOAD-SYSTEM (SYSTEM)
   (MAPC #'(LAMBDA (FILE) (LOAD (COMPILE-FILE FILE)))
         (SYSTEM-SOURCES SYSTEM)))
</pre>

<p>
Учитывая этот уровень поддержки, система будет "определена" если записать:
</p>

<pre> (DEFINE-SYSTEM-SOURCES 'MYSYS
   "MACROS.LISP" "UTILITIES.LISP" "MAIN.LISP").
</pre>

<p>
После определения, такая система может быть обработана следующими запросами:
</p>

<pre> (HARDCOPY-SYSTEM 'MYSYS)
 (COMPILE-AND-LOAD-SYSTEM 'MYSYS)
</pre>

<h3>Частичное упорядочение зависимостей</h3>

<p>
Одна проблема с этой формулировкой состоит в том, что отношения между модулями
системы могут быть довольно сложными. Например, некоторые файлы в системе
могут не зависеть от других файлов, а может быть потребоваться перекомпиляция
всей системы только потому, что изменился один файл.  Чтобы попытаться объяснить
это, определение <code>COMPILE-AND-LOAD-SYSTEM</code> может быть изменено следующим
образом:
</p>

<pre> (DEFUN COMPILE-AND-LOAD-SYSTEM (SYSTEM)
   (LET ((COMPILE-FLAG NIL))
     (DOLIST (FILE (SYSTEM-SOURCES SYSTEM))
       (SETQ COMPILE-FLAG
             (OR COMPILE-FLAG (NEEDS-COMPILATION? FILE)))
       (IF COMPILE-FLAG (COMPILE-FILE FILE))
       (LOAD (BIN-FILE FILE)))))
</pre>

<p>
С этим пересмотренным определением файлы в списке исходных файлов системы будут иметь
отношение зависимостей слева направо. Рассмотрим снова систему, определяемую как:
</p>

<pre> (DEFINE-SYSTEM-SOURCES 'MYSYS
   "MACROS.LISP" "UTILITIES.LISP" "MAIN.LISP").
</pre>

<p>
Если <tt>MACROS.LISP</tt> изменяется, <tt>UTILITIES.LISP</tt> и 
<tt>MAIN.LISP</tt> придется перекомпилировать.  Но если <tt>MAIN.LISP</tt> 
изменяется, это будет единственный файл, который будет перекомпилирован.
</p>

<p>
Простая зависимость определяемая слева на право полезна для некоторых 
приложений, но может вызвать много ненужной работы в других.  Причина в
том, что фактическое упорядочение может быть только частичным, а это 
обозначение принудительно задает полное 
<a name="footref2">упорядочение</a><a href="#footnote2">[2]</a>.
</p>

<p>
Например, легко представить, что наша система построена таким образом, что если
файл <tt>MACROS.LISP</tt> изменился, необходимо перекомпилировать оба файла <tt>UTILITIES.LISP</tt> и <tt>MAIN.LISP</tt>, но если изменился один файл 
<tt>UTILITIES.LISP</tt> или <tt>MAIN.LISP</tt>, только один файл потребует
перекомпиляции.
</p>

<p>
Поскольку этот пример нотации не позволяет адекватно выразить такие сложные
отношения, она должна быть признана неадекватной для рассмотрения "общего
случая."  Тем не менее, есть случаи, когда её было бы достаточно, и было бы 
неплохо использовать её (или что-то столь же простое) для этих случаев..
</p>

<h3>Ортогональные типы зависимостей</h3>

<p>
Еще одна проблема с нашей первоначальной формулировкой касается 
нескольких независимых цепочек зависимостей. Информация о
зависимостях для компиляции может не совпадать с информацией о зависимостях
для создания среды выполнения.
</p>

<p>
Если единственной целью является компиляция системы, может быть много файлов
которые не нужно загружать, поскольку они содержат утилиты, используемые
только во время выполнения. И, в качестве альтернативы, если целью является
загрузка уже скомпилированной системы, некоторые файлы(например, те, которые
содержат только макросы) могут не понадобиться.  Если и компиляция, и загрузка
должны чередоваться, может возникнуть третий порядок.
</p>

<p>
Адекватная нотация для описания систем должна предлагать нотацию для определения
различных видов отношений зависимости, и, вероятно, должна быть расширяемой
(допускающей добавление новых видов зависимостей).
</p>

<h2>III. Существующие Инструменты</h2>

<h3>Unix MAKE Facility</h3>

<p>
<a name="ref-Feldman-78">Средство Unix <tt>MAKE</tt> </a> <a href="#Feldman-78">[Feldman 78]</a> часто называют моделью "правильного способа определения системы."  Оно синтаксически
простое и обеспечиват разумную мощь.
</p>

<p>
makefile содержит команды Unix оболочки(shell), дополненные информацией о том,
какие модули кода зависят от каких других.  Когда вызывается команда <tt>make</tt>,
создается впечатление, что все команды оболочки были выполнены, за исключением того,
что некоторые команды оболочки могут быть "оптимизированы", если в информации о
зависимости указано, что они не нужны для сохранения корректности.
</p>

<p>
Чтобы конкретизировать, вот пример того, как система может быть определена
в файле makefile:
</p>

<pre> mysys: a.o b.o
          cc a.o b.o -lm -o pgm
   a.o: incl a.c
          cc -c a.c
   b.o: incl b.c
          cc -c b.c
</pre>

<p>
Первая строка определяет, что существует некоторый модуль, называемый 
<tt>mysys</tt>, который необходимо обновить, если <tt>a.o</tt> или 
<tt>b.o</tt> имеют более позднюю дату изменения. Строка с отступом,
следующя за этой строкой, указывает, как выполнять обновление; в частности,
она связывает(линкует/links) скомпилированные файлы <tt>a.o</tt>, <tt>b.o</tt> 
и стандартную библиотеку <tt>m</tt>.  Третья и пятая строки определяют
модули <tt>a.o</tt> и <tt>b.o</tt>,
говоря, что они зависят от исходных файлов <tt>.c</tt>, а также от некоторого
файла с именем <tt>incl</tt> (на который вероятно они ссылаются внутренне
через <tt>#include</tt>).
</p>

<p>
Чтобы упростить сравнение, мы можем сделать вид, что используем выражения
на Lisp, а не требовать специального синтаксического анализатора. В таком
случае файл makefile может содержать выражения вроде:
</p>

<pre> (DEFINE-FOR-MAKE MYSYS
     (MYSYS ("a.o" "b.o")
            (LOAD-IF-NOT-LOADED "a")
            (LOAD-IF-NOT-LOADED "b")
            (LOAD-IF-NOT-LOADED "m"))
     ("a.o" ("incl" "a.c")
            (COMPILE-FILE "a.c"))
     ("b.o" ("incl" "b.c")
            (COMPILE-FILE "b.c")))
</pre>

<p>
Одна проблема с <tt>MAKE</tt> заключается в том, что не вся информация в
файле makefile указывается явно. Например, тот факт, что исходными файлами
системы являются <tt>incl</tt>, <tt>a.c</tt>, <tt>b.c</tt> нигде не указан
явно.
Ничто(кроме надежды на то, что файлы <tt>.o</tt> не являются исходными файлми,
а все остальные таковые) не идентифициует их как файлы исходного кода. 
Программист, желающий написать утилиту для создания печатной копии исходных
кодов системы, не сможет выбрать эту информацию утилитой, из содержимого makefile.
</p>

<p>
<tt>MAKE</tt> не предлагает теории о том как включать или обрабатывать дополнительную
информацию.  Например, указание хвоста каждого предложения модуля (часть предложения
после двоеточия в оригинальном синтаксисе Unix) говорит о том, как создать модуль,
хороша для языка использующего только компиляцию, но не целесообразна для языка подобного
lisp, который объединяет понятие интерпретатора и компилятора, который может разделять(совершать) эти процессы при загрузке. Не существует очевидного способа
расширения <tt>MAKE</tt> в направлении совместимости вверх, чтобы можно было задавать
команды для компиляции модулей, а также команды для их загрузки. Также не предусмотрено добавление других видов информации, таких как альтернативное представление о том, что означает устаревание модулей или как обрабатывать циклические зависимости. 
</p>

<p>
Фактически, <tt>MAKE</tt> представляет собой нечто большее, чем пакетное
средство, с простым но негибким условием игнорирования ненужных команд. Как и
в случае с обычными пакетными файлами, для выполнения двух операций 
(<i>например,</i> компиляции и загрузки) требует двух пактных файлов.  
Хотя это может быть
синтаксически удобно для некоторых распространенных приложенй на языках
выполняющих только компиляцию под Unix, <tt>MAKE</tt> 
не представляет теории о том, как поддерживать(сопровождать) системы.
</p>

<h3>Средство DEFSYSTEM</h3>

<p>
<a name="ref-Weinreb-81">Средство Lisp Machine <code>DEFSYSTEM</code> </a> <a href="#Weinreb-81">[Weinreb 81]</a> 
позиционирует себя как "общий и расширяемый" инструмент для обслуживания систем,
разбитых на несколько файлов. Он представляет возможность отметить, какие файлы
принадлежат каким модулям, какие модули зависят от каких других модулей (как для
компиляции, так и для загрузки), и является расширяемым, что позволяет добавлять
новые "преобразования" для построения системы.
(такие как альтернативные компиляторы и загрузчики).
</p>

<p>
Информация о структуре системы определяется специальной формой
<code>DEFSYSTEM</code> .
Позже, <code>MAKE-SYSTEM</code> может быть вызван для выполения
предопределенного набора операций над системой.
</p>

<p>
<font color="green">
[Обратите внимание, что мы ссылаемся здесь на формы <code>DEFSYSTEM</code> 
как специальные формы, когда они являются макроформами.
 В то время когда эта статья была написана до Common Lisp, значение термина
"специальная форма" еще развивалось, и означало то, что Common Lisp
 назвал бы "любой составной формой, которая не является формой функции"; то есть,
 они включают в себя, то что в Common Lisp называется специальными формами, и то,
 что Common Lisp называет маро формами(макросами).  Лично я предпочитаю это старое
 значение специальной форме, потому что оно не зависит от реализации.<br>
 --<i>KMP</i> 14-Jan-2001]
</font>
</p>

<p>
Вот пример описания системы, записанной в нотации <code>DEFSYSTEM</code>:
</p>

<pre> (DEFSYSTEM MYSYS
   (:MODULE MACROS ("incl"))
   (:MODULE A ("a"))
   (:MODULE B ("b"))
   (:MODULE MLIB ("m"))
   (:FASLOAD MLIB)
   (:COMPILE-LOAD MACROS)
   (:COMPILE-LOAD-INIT A (MACROS)
                         (:FASLOAD MACROS)
                         (:FASLOAD MLIB))
   (:COMPILE-LOAD-INIT B (MACROS)
                         (:FASLOAD MACROS)
                         (:FASLOAD MLIB A )))
</pre>

<p>
Предложения <a name="footref3"><code>:MODULE</code></a><a href="#footnote3">[3]</a> 
определяют, какие файлы принадлежат каждому из модулей. Например, модуль <code>MACROS</code> 
ссылается на файл <tt>"incl.lisp"</tt>,
модуль A ссылается на <code>"a.lisp"</code>, <i>и т.д.</i>
</p>

<p>
Предложение <code>:FASLOAD</code> для <code>MLIB</code>
говорит, что <code>"m.lisp"</code> это стандартная библиотека,
которая может быть загружена. Это определение не указывает, когда
оно может быть перекомпилировано; предположительно, этим занимается
какое-то другое агенство.
</p>

<p>
Предложение <code>:COMPILE-LOAD</code> для <code>MACROS</code>
говорит, что <tt>"incl.lisp"</tt> является частью системы и должен
быть перекомпилирован при изменении, но у него нет особых
предварительных условий, которые должны быть выполнены перед компиляцией
или загрузкой.
</p>

<p>
Предложения <code>:COMPILE-LOAD-INIT</code> для <code>A</code> и <code>B</code> определяют разлличные виды информации о зависимостях. Оба должны быть перекомпилированы
не только если они сами изменяются, но также при изменении <code>MACROS</code>.  
Перед компиляцией <code>A</code>, необходимо сначала загрузить <code>MACROS</code>; 
перед загрузкой <code>A</code>, необходимо сначала загрузить <code>MLIB</code>.  
Перед компиляцией <code>B</code>, необходимо сначала загрузить <code>MACROS</code>; 
перед загрузкой <code>B</code>, необходимо сначала загрузить <code>MLIB</code> и <code>A</code>.
</p>

<p>
Хотя имена вроде <code>:COMPILE-LOAD</code> могут выглядеть как имена функций, это не так.  Они просто заявляют, что компиляция и загрузка
могут возникнуть при определенных обстоятельствах. Обозначение(нотация)  <code>DEFSYSTEM</code>, в отличие от обозначения <tt>MAKE</tt>, 
является декларативным, а не процедурным.  Из-за этого <code>MAKE-SYSTEM</code> может выполнять более одного вида операций
(для каждой формы <code>DEFSYSTEM</code>),
где <tt>MAKE</tt> может выполнять только одну (для каждого makefile).
Например, при определенных аргументах, <code>MAKE-SYSTEM</code> скомпилирует
систему.
Учитывая разные аргументы он просто загрузит уже скомпилированную версию
системы.
</p>

<p>
С другой стороны, набор операций, которые будет выполнять <code>MAKE-SYSTEM</code>, является заранее заданным и не расширяемым. Это означает, что если бы кто-то хотел добавить новую утилиту (<i>например,</i> для создния
распечаток исходных кодов), не было бы никакого способа следать это,
потому что не существует объявленного пользователем механизма для запроса
списка исходных файлов системы.  Информация присутствует и используется
внутри различных системных утилит, но не объявляется пользователями как
часть стандартной абстракции.
</p>

<p>
Другой недостаток, который часто слышат о <code>DEFSYSTEM</code>
- это то, что он был разработан для работы с тяжёлыми случаями, для простых
задач он  громоздок и неудобен в использовании.
</p>

<p>
Ещё одна проблема, которая способствует общему ощущению неуклюжести,
заключается в том, что нет транзитивности информации о зависимостях
между модулями <code>DEFSYSTEM</code>.
Следовательно, если <code>DEFSYSTEM</code> сообщают, что <tt>C.LISP</tt> 
зависит от <tt>B.LISP</tt> и что <tt>B.LISP</tt> зависит от <tt>A.LISP</tt>,
<code>DEFSYSTEM</code> не сделает заключение, о том, что
<tt>C.LISP</tt> зависит от <tt>A.LISP</tt>.
Технически, было бы не правильно делать иначе, потому что это может быть случаем, когда часть <tt>B.LISP</tt>, которая завсит от <tt>A.LISP</tt>,
не используется в <tt>C.LISP</tt>.
<a name="footref4"> Тем не менее,
результатом такого решения со стороны разработчиков <code>DEFSYSTEM</code> является то, что большие формы <code>DEFSYSTEM</code> имеют тенденцию
принимать пирамидальную форму, так как более поздние спецификации загрузки-компиляции вынуждены явно указывать огромное количество зависимостей явно:</a><a href="#footnote4">[4]</a> 
</p>

<pre> (defsystem KBE
   (:name "Knowledge-Based-Editor")
   (:short-name "KBE")
     .
     .
     .
   (:module LET "KBE: LISPM2; LET" :package KBE)
   (:module LETS "KBE: LMLIB; LETS")
   (:module PP "KBE: LMLIB; GPRINT")
   (:module BASE ("BASIC" "NOISE" "SETS" "CONDITIONS" "ENGLISH"
                  "SYSTEM-MAGIC" "FLAVOR-MAGIC"))
   (:module MACRO ("MACRO"))
   (:module KVARS "KVARS")
     .
     .
     .
   (:fasload PP)
   (:fasload LET)
   (:fasload LETS)
   (:compile-load-init BASE (PP)
                            (:fasload PP LET LETS)
                            (:fasload PP))
   (:compile-load-init MACRO (PP)
                             (:fasload PP LET LETS BASE)
                             (:fasload BASE))
   (:compile-load-init KVARS (PP MACRO)
                             (:fasload PP LET LETS BASE MACRO)
                             (:fasload BASE))
   (:compile-load-init KMAC (PP MACRO)
                            (:fasload PP LET LETS BASE MACRO KVARS)
                            (:fasload BASE KVARS))
   (:compile-load-init IMAC (PP MACRO KMAC)
                            (:fasload PP LET LETS BASE MACRO KVARS KMAC)
                            (:fasload BASE KVARS KMAC))
   (:compile-load-init MBOX (PP MACRO)
                            (:fasload PP LET LETS BASE MACRO KVARS IMAC)
                            (:fasload BASE KVARS IMAC))
   (:compile-load-init BEHAVE (PP MACRO IMAC)
                              (:fasload PP LET LETS BASE MACRO KVARS IMAC)
                              (:fasload BASE KVARS IMAC MBOX))
   (:compile-load-init KUTIL (PP MACRO IMAC BEHAVE)
                             (:fasload PP LET LETS BASE MACRO KVARS IMAC BEHAVE)
                             (:fasload BASE KVARS IMAC MBOX BEHAVE))
     .
     .
     .
   (:compile-load-init MAGIC (PP MACRO IMAC BEHAVE SIMPLE ED1 SOCIETY)
                             (:fasload PP LET LETS BASE MACRO KVARS IMAC
                                       BEHAVE KUTIL SIMPLE LD1 SOCIETY SINDRD ZMAGIC)
                             (:fasload BASE KVARS IMAC MBOX BEHAVE KUTIL ED1
                                       SOCIETY SINDRD BRIDGE ZMAGIC))
   ...)
</pre>

<p>
<code>DEFSYSTEM</code> является расширяемым, но в дополнении к другим
проблемам, большая часть данных, доступным авторам расширений, представлена
в виде специальных переменных, которые доступны во время его 
"преобразований".  Чтобы проилюстрировать это, мы включили отрывок из
раздела Lisp Machine Manual, в котором описаны переменные состояния,
которые можно использовать при написании расширений <code>DEFSYSTEM</code>:
</p>

<blockquote>
<dl>
<dt>
<table width="80%">
 <tbody><tr>
  <td valign="top" align="left"><code>SI:*SYSTEM-BEING-MADE*</code></td>
  <td valign="top" align="right"><i>Variable</i></td>
 </tr>
</tbody></table>
</dt>
<dd>
<p>
Внутренняя структура данных, проторая представляет создаваемую систему.
</p>
</dd>

<dt>
<table width="80%">
 <tbody><tr>
  <td valign="top" align="left"><code>SI:*MAKE-SYSTEM-FORMS-TO-BE-EVALED-BEFORE*</code></td>
  <td valign="top" align="right"><i>Variable</i></td>
 </tr>
</tbody></table>
</dt>
<dd>
<p>
Список форм, которые вычисляются перед выполнением преобразований.
</p>
</dd>

<dt>
<table width="80%">
<tbody><tr>
<td valign="top" align="left">
<code>SI:*MAKE-SYSTEM-FORMS-TO-BE-EVALED-AFTER*</code></td>
<td valign="top" align="right">
<i>Variable</i></td></tr></tbody></table>
</dt>
<dd>
<p>
Список форм, которые вычисляются после выполнения преобразований.
</p>
</dd>

<dt>
<table width="80%">
<tbody><tr>
<td valign="top" align="left">
<code>SI:*MAKE-SYSTEM-FORMS-TO-BE-EVALED-FINALLY*</code></td>
<td valign="top" align="right">
<i>Variable</i></td></tr></tbody></table>
</dt>
<dd>
<p>
Список форм, которые вычисляются после завершения тела
<code>MAKE-SYSTEM</code>.  Он отличается от
<code>SI:*MAKE-SYSTEM-FORMS-TO-BE-EVALED-AFTER*</code> тем, что эти
формы вычисляются вне "контекста компилятора," что иногда
имеет значение.
</p>
</dd>

<dt>
<table width="80%">
<tbody><tr>
<td valign="top" align="left">
<code>SI:*QUERY-TYPE*</code></td>
<td valign="top" align="right">
<i>Variable</i></td></tr></tbody></table>
</dt>
<dd>
<p>
Контролирует, как задаются вопросы. Его нормальное значение 
<code>:NORMAL</code>. <code>:NOCONFIRM</code>
означает, что вопросы задаваться не будут, а <code>:SELECTIVE</code>
задает вопросы для каждого отдельного файла.
</p>
</dd>
</dl>

<pre> .
 .
 .
</pre>

<dl>
<dt>
<table width="80%">
<tbody><tr>
<td valign="top" align="left">
<code>(SI:DEFINE-MAKE-SYSTEM-SPECIAL-VARIABLE </code><i>var</i><code> </code><i>val</i><code> [</code><i>defvar-p</i><code>])</code></td>
<td valign="top" align="right">
<i>Special Form</i></td></tr></tbody></table>
</dt>
<dd>
<p>
Вызывает привязку <i>var</i> к <i>val</i>, 
которая вычисляется во время <code>MAKE-SYSTEM</code>,
во время вызова тела <code>MAKE-SYSTEM</code>.
Это позволяет вам определять  новые переменные, подобные перечисленным выше.
Если <i>defvar-p</i> указана как (или по умолчанию) <code>T</code>,
<i>var</i> определяется с помощью <code>DEFVAR</code>.
Это не дает начального значения.
Если <i>defvar-p</i> указан как <code>NIL</code>,
<i>var</i> принадлежит какой-то другой программе и здесь не
определяется(not <code>DEFVAR</code>'ed).
</p>
</dd>
</dl>

</blockquote>

<p>
Поскольку информация таким образом внедряется процедурно, она может не быть
явной в произвольные моменты времени. Кроме того, он навязывает множество заренее
определенных механизмов для описания систем, которые могут быть не удобны или даже
не актуальны в определенных ситуациях.
</p>

<p>
Эти проблемы с дизайном <code>DEFSYSTEM</code> затрудняют разработку
инструментов, которые взаимодействуют с инструментами предоставляемыми
<code>DEFSYSTEM</code>.
Конечным результатом является то, что формализм <code>DEFSYSTEM</code> 
гораздо менее гибок, чем нам хотелось бы.
</p>

<h2>IV. Предложение(План)</h2>

<p>
И <code>DEFSYSTEM</code> и <tt>MAKE</tt> предлагают интересную функциональность,
но эта функциональность тесно связана с сопровождающим синтаксисом.
Ни одна из них не стремиться предоставить теорию о том, как сделать доступной спецификацию
системы без привязки пользователя к определенному синтаксису.
</p>

<p>
Не зависимо от природы языка спецификаций, виды высокоуровневых операций,
выполняемых с системами не будут меняться.  Мы по прежнему хотим редактировать,
компилировать, загружать и печатать системы.  Следовательно,
вместо того, чтобы предлагать еще один язык описания системы с
<i>новой, улучшеной</i> системой обозначений(нотацией),
мы предложим структуру, в которой синтаксис и функциональные возможности могут
изменяться независимо.
</p>

<p>
В этом разделе мы рассмотрим детали предложения, но его суть заключается в том,
что с каждой системой ассоциировать какой-то объект, которые соответствующим образом
реагирует на зараенее определенный набор операций, которые поддерживают
соответствующее обслуживание системы.  Иными словами, мы утверждаем, что ключевая
проблема предыдущих утилит обслуживания систем, заключалась в том, что они либо не были
объекто-ориентированными, либо не использовали свою объектно-ориентированную природу
в своих лучших интересах.
</p>

<p>
Для реализации этого предложения будет достаточен любой вида средств имеющий
обобщенные операции (<i>например,</i> которые предусмотрены в <a name="ref-Rees-84"><tt>T</tt></a> <a href="#Rees-84">[Rees 84]</a>
или <a name="ref-Theriault-83"><tt>Act-II</tt></a> <a href="#Theriault-83">[Theriault 83]</a>).
Везде, где возможно, для демонстрации мы будем использовать абстрактрый синтаксис вызова функций.  
В тех местах, где требуются примеры из определенного языка, мы будем использовать
 <tt>Lisp Machine Lisp</tt> для демонстрационных целей.
</p>

<h3>Основной(Базовый) Протокол</h3>

<p>
Изучая операции, которые обычно выполняются над файлами, мы можем составить
список общих операций, которые мы могли бы ожидать в системах.  Одним очевидным
выбором является операция обновления(update), которая включает в себя компиляцию или
перевод с одного языка на другой, генерацию синтаксического аналлизатора,
<i>и т.д.</i> Другой является (instantiation)создание работающего экземпляра, 
которая включает загрузку файлов или выполнение некоторых видов установочного кода.  
Другими полезными операциями могут быть редактирование, печать, и архивация.
</p>

<p>
Для поддержки этих операций мы определяем следующие функции:
</p>

<blockquote>
<dl>
<dt><code>(<font color="green">SYSDEF:</font>GENERATE-PLAN </code><i>system</i><code> </code><i>operation</i><code>) -&gt; </code><i>actions</i></dt>
<dd>
<p>
Если задано имя абстрактной операции(<i>operation</i>) (такое как <code>:UPDATE</code>,
<code>:INSTANTIATE</code>, или <code>:HARDCOPY</code>),
возвращает список действий (<i>actions</i>) (абстракнтый пошаговый план), которые будут
выполнять операцию(<i>operation</i>).
</p>
</dd>

<dt><code>(<font color="green">SYSDEF:</font>EXECUTE-PLAN </code><i>system</i><code> </code><i>actions</i><code>)</code></dt>
<dd>
<p>
Выполняет список действий(<i>actions</i>) (или плановых шагов),
например, тех, которые возвращены из запроса
<code><font color="green">SYSDEF:</font>GENERATE-PLAN</code>.
</p>
</dd>

<dt><code>(<font color="green">SYSDEF:</font>EXPLAIN-PLAN </code><i>system</i><code> </code><i>actions</i><code>)</code></dt>
<dd>
<p>
Напечатает объяснение того, каков будет эффект от выполнения действий(<i>actions</i>).
</p>
</dd>

<dt><code>(<font color="green">SYSDEF:</font>SOURCE-FILES </code><i>system</i><code>) -&gt; </code><i>files</i></dt>
<dd>
<p>
Возвращает список исходных файлов для системы.
</p>
</dd>
</dl>
</blockquote>

<p>
К этому базовому набору мы добавим две следующие функции. Можно утверждать,
что они являются излишними в присутствии вышеуказанных функций, но на практике
их наличие значительно повысит ясность кода.
Добавляя их к стандартному протоколу, мы поощряем более ясный стиль программирования
и стандартизируем термины:
</p>

<blockquote>
<dl>
<dt><code>(<font color="green">SYSDEF:</font>EXECUTE-ACTION </code><i>system</i><code> </code><i>action</i><code>)</code></dt>
<dd>
<p>
Выполняет заданное действие(<i>action</i>) (шаг плана).
</p>
</dd>

<dt><code>(<font color="green">SYSDEF:</font>EXPLAIN-ACTION </code><i>system</i><code> </code><i>action</i><code>)</code></dt>
<dd>
<p>
Печатает объяснение того, каков будет эффект от выполнения действия.
</p>
</dd>
</dl>
</blockquote>

<p>
Для удобства, мы также определим, что если аргумент <code>EXPLAIN</code>
или <code>EXECUTE</code> является именем операции, а не набором шагов, 
план будет сгенерирован автоматически.  Это позволяет нам сказать:
</p>

<blockquote>
<table>
<tbody><tr>
<td>&nbsp;</td>
<td><code>(<font color="green">SYSDEF:</font>EXECUTE-PLAN </code><i>system</i><code> :UPDATE)</code></td>
</tr>
<tr>
<td>и&nbsp;</td>
<td><code>(<font color="green">SYSDEF:</font>EXPLAIN-PLAN </code><i>system</i><code> :UPDATE)</code></td>
</tr>
</tbody></table>
</blockquote>

<p>
там, где раньше мы бы сказали:
</p>

<blockquote>
<table>
<tbody><tr>
<td>&nbsp;</td>
<td><code>(<font color="green">SYSDEF:</font>EXPLAIN-PLAN </code><i>system</i><code> (<font color="green">SYSDEF:</font>GENERATE-PLAN </code><i>system</i><code> :UPDATE))</code></td>
</tr>
<tr>
<td>и&nbsp;</td>
<td><code>(<font color="green">SYSDEF:</font>EXECUTE-PLAN </code><i>system</i><code> (<font color="green">SYSDEF:</font>GENERATE-PLAN </code><i>system</i><code> :UPDATE))</code>.</td>
</tr>
</tbody></table>
</blockquote>

<h3>Определение систем</h3>

<p>
По нашему предложению системы описываются с использованием
специальной формы <code>DEFINE-SYSTEM</code>.  Она создает
системный объект и сохраняет его глобально, для последующего
использования. Она имеет синтаксис:
</p>

<blockquote>
<p>
<code>(<font color="green">SYSDEF:</font>DEFINE-SYSTEM </code><i>name</i><code> </code><i>type</i><code> .  </code><i>options</i>).
</p>
</blockquote>

<p>
Точная природа параметров(<i>options</i>) будет зависеть от типа
(<i>type</i>) системы.
Для некоторых систем это может быть просто списк файлов.  Для других,
это может быть более сложная структура данных, определяющая конкретную информацию
о зависимостях.  Это предложение разработано в явном виде, чтобы избежать принятия
позиции, какая идет в этой части в спецификации системы.
</p>

<p>
Для поддержки такого типа обработки опций, специфичных для типа, нам нужны функции
для обработки списка опций, специфичных для каждого типа:
</p>

<blockquote>
<dl>
<dt><code>(<font color="green">SYSDEF:</font>PROCESS-OPTIONS </code><i>system</i><code> </code><i>options-list</i><code>)</code></dt>
<dd>
<p>
Обрабатывает список опций(options-list), такой как тело формы <code>DEFINE-SYSTEM</code>.
Это может(но не обязательно) быть выполнено путем отображения(mapping) функции
<code><font color="green">SYSDEF:</font>PROCESS-OPTION</code> на список опций(options-list).
</p>
</dd>

<dt><code>(<font color="green">SYSDEF:</font>PROCESS-OPTION </code><i>system</i><code> </code><i>name</i><code> . </code><i>data</i><code>)</code></dt>
<dd>
<p>
Обрабатывает один параметр с указанным именем или данными.  Имя опции 
<code>:NAME</code> должно быть обработано.
Обработка любой другой опции осуществляется по усмотрению для конкретного
типа системы.
</p>
</dd>
</dl>
</blockquote>

<h3>Создание Системных Объектов</h3>

<p>
Специальная форма <code>DEFINE-SYSTEM</code> поддерживается обычной функцией
называемой  <code>CREATE-SYSTEM</code>, которая имеет синтаксис:
</p>

<blockquote>
<p><code>(<font color="green">SYSDEF:</font>CREATE-SYSTEM </code><i>name</i><code> </code><i>type</i><code> </code><i>options</i><code>)</code>.</p>
</blockquote>

<p>
<code>CREATE-SYSTEM</code> возаращает объект, представляющий систему, но
не сохраняет его ни в каком глобальном месте.
Такой объект называется  анонимной системой(<i>anonymous system</i>).
<code>CREATE-SYSTEM</code> (и следовательно <code>DEFINE-SYSTEM</code>)
работает создавая объект назначенного системного вида, а затем вызывает 
соотвествующие функции, чтобы установить его имя и обработать его параметры.
</p>

<h3>Расширяемость</h3>

<p>
Чтобы быть соответствующим образом расширяемой, каждая реализация должна
была бы определять, как эти функции связаны с средством обобщенных операций
предоставляемым этим языком.  Например, на Lisp Machine, интерфейс к
разновидностям может выглядеть так:
</p>

<pre> (DEFUN <font color="green">SYSDEF:</font>PROCESS-OPTIONS (SYSTEM OPTIONS-ALIST)
   (SEND SYSTEM :PROCESS-OPTIONS OPTIONS-ALIST))

 (DEFUN <font color="green">SYSDEF:</font>PROCESS-OPTION (SYSTEM NAME &amp;REST DATA)
   (LEXPR-SEND SYSTEM :PROCESS-OPTION NAME DATA))

   .
   .
   .
</pre>

<font color="green">
<p>
[<tt>LEXPR-SEND</tt> относится к <tt>SEND</tt> как <tt>APPLY</tt> 
относится к <tt>FUNCALL</tt> в Common Lisp.
Однако в Maclisp и на диалекте Lisp Machine's Zetalisp,
<tt>APPLY</tt> была функцией ровно двух аргументов, и нужно было использовать
<tt>LEXPR-FUNCALL</tt> чтобы получить версию <tt>APPLY</tt>
с несколькими аргументами, которую имеет Common Lisp.  <tt>LEXPR-SEND</tt> был назван
в паралелель с
<tt>LEXPR-FUNCALL</tt>.  Вместо того чтобы делать:
</p>

<pre> (LEXPR-FUNCALL #'SEND msg-key msg-key<sub>1</sub> ... msg-key<sub>m</sub> more-msg-keys)
</pre>

<p>
можно было просто написать:
</p>

<pre> (LEXPR-SEND msg-key msg-key<sub>1</sub> ... msg-key<sub>m</sub> more-msg-keys)
</pre>

<p>
Часть этого имени "<tt>LEXPR-</tt>" возникает потому, что в Maclisp
функции с фиксированным числом аргументов назывались "exprs",
а функции с переменным числом аргументов назывались "lexprs".
Обратите внимание, что действие выполняемое <tt>SEND</tt> не обязательно
относиться к функции(или обрабочику сообщения) с переменным числом аргументов;  
но такая функция (или обработчик сообщений) может быть реализована с помощью
<tt>LEXPR-SEND</tt>.
<br>
 --<i>KMP</i> 21-Jan-2001]
</p>
</font>

<h3>Использование Наследования</h3>

<p>
Языки, которые предоставляют обобщенные операции и средства для наследования
типов, вероятно, предложат по крайней мере два предопределенных типа.
</p>

<p>
Тип с названием <code>SYSTEM</code> должен быть основным.
Он не должен иметь никаких свойств, кроме идентификации объекта
как системы.  Разработчики, которые хотят начать все заново "с нуля", при
разработке новых типов систем, придерживающихся протокола, который мы предлагаем,
начнут с типа <code>SYSTEM</code> и будут работать от него.
</p>

<p>
Другой тип, который мы назовем <code>VANILLA-SYSTEM</code>,
может предложить некоторые общие функциональные возможности, которые 
могут быть полезными для многих типов систем.
Используя какой-либо механизм наследования, подходящий для языка, разработчики
многих новых типов систем могут наследовать от этого, немного менее общего типа,
вместо того, чтобы начинать с нуля и строить свой тип системы из типа  <code>SYSTEM</code>.
Естественно, <code>VANILLA-SYSTEM</code> наследуется от <code>SYSTEM</code>.
</p>

<p>
Например, в Lisp Machine настройку можно выполнить, смешав <code>VANILLA-SYSTEM</code>
с новой особенностью(вкусом), добавив  или изменив несколько методов.  Ничто не мешает
разработчику начать с нуля и реализовать все методы с нуля; но обычно это требует больше
работы, чем необходимо.
</p>

<p>
Типичная системная особенность может выглядеть так:
</p>

<pre> (DEFFLAVOR system-type (...instance variables...)
            (VANILLA-SYSTEM))
</pre>

<font color="green">
<p>
[Lisp Machine <code>DEFFLAVOR</code> был приблизительно эквивалентен
 <code>DEFCLASS</code>, за исключением того, что список слотов (называемый
переменные экземпляра("instance variables")) и список суперклассов шли в
обратном порядке, а синтаксис для слотов немного отличался:
</p>

<pre> (DEFCLASS system-type (VANILLA-SYSTEM)
   (...slots...))
</pre>

<p>
 --<i>KMP</i> 14-Jan-2001]
</p>
</font>

<p>
с последующим определением новых или индивидуализированных(переписанных для своих нужд) методов.
</p>

<p>
Например, на Lisp Machine,
можно ожидать, что метод <code>:PROCESS-OPTIONS</code> будет определяться как:
</p>

<pre> (DEFMETHOD (VANILLA-SYSTEM :PROCESS-OPTIONS) (OPTIONS)
   (DOLIST (OPTION OPTIONS)
     (LEXPR-SEND SELF :PROCESS-OPTION OPTION)))
</pre>

<font color="green">
<p>
[Lisp Machine <code>DEFMETHOD</code> был похож на
 Common Lisp <code>DEMETHOD</code>, но он выполнял диспетчеризацию только по одному,
 предполагаемому аргументу, и его синтаксис был другим. Кроме того, имя метода обычно
 находилось в Common Lisp вместо преобладающего пакета, поскольку вызов выполнялся бы
 функцией <code>SEND</code>.
 В Common Lisp, вышеупомянутый <code>DEFMETHOD</code> может быть записан: 
</p>

<pre> (DEFMETHOD PROCESS-OPTIONS ((SYSTEM VANILLA-SYSTEM) OPTIONS)
   (DOLIST (DATA OPTIONS)
     (APPLY #'PROCESS-OPTION SYSTEM (CAR DATA) (CDR DATA)))
   SYSTEM)
</pre>

<p>
И вместо синтаксиса Lisp Machine:
</p>

<blockquote>
<p>
<code>(SEND </code><i>system</i><code> :PROCESS-OPTIONS </code><i>options</i><code>)</code>
</p>
</blockquote>

<p>
в Common Lisp можно вместо этого написать:
</p>

<blockquote>
<p>
<code>(PROCESS-OPTIONS </code><i>system</i><code> </code><i>options</i><code>)</code>
</p>
</blockquote>

<p>
 --<i>KMP</i> 14-Jan-2001]
</p>
</font>

<p>
Он определен как часть <code>VANILLA-SYSTEM</code>, чтобы избавить
всех от необходимости писать тот же метод. Фактически, 
<code>VANILLA-SYSTEM</code> может даже определить
<code>:PROCESS-OPTION</code> для использования диспетчеризации метода
<code>:CASE</code> (так что обработка каждого типа опций может быть
определена отдельной формой <code>DEFMETHOD</code>).
Если это так, мы могли бы также ожидать, чтобы найти такие определения
и в <code>VANILLA-FLAVOR</code>:
</p>

<pre> (DEFMETHOD (VANILLA-SYSTEM :CASE :PROCESS-OPTION :FULL-NAME) (NAME)
   (SETQ FULL-NAME (STRING NAME)))

 (DEFMETHOD (VANILLA-SYSTEM :CASE :PROCESS-OPTION :SHORT-NAME) (NAME)
   (SETQ SHORT-NAME (STRING NAME)))

 (DEFMETHOD (VANILLA-SYSTEM :CASE :PROCESS-OPTION :NAME) (NAME)
   (IF (NOT SHORT-NAME) (SETQ SHORT-NAME (STRING NAME)))
   (IF (NOT FULL-NAME) (SETQ FULL-NAME (STRING NAME))))

   .
   .
   .

 (DEFMETHOD (VANILLA-SYSTEM :OTHERWISE :PROCESS-OPTION) (NAME &amp;REST DATA)
   (FERROR "Bad option: ~S~%Data: ~S" NAME (COPYLIST DATA)))
</pre>

<font color="green">
<p>
[Комбинация методов <code>:CASE</code> была ляпом, позволяющим ограниченную
 диспетчеризацию с двумя аргументами, где воторым агрументом было второе ключевое
 слово. Примерный эквивалент приведенного выше кода в Common Lisp:
</p>

<pre> (DEFMETHOD PROCESS-OPTION ((SYSTEM VANILLA-SYSTEM) (KEY (EQL :NAME)) &amp;REST DATA)
   (WITH-SLOTS (SHORT-NAME FULL-NAME) SYSTEM
     (DESTRUCTURING-BIND (DATUM) DATA
       (IF (NOT SHORT-NAME) (SETQ SHORT-NAME (STRING DATUM)))
       (IF (NOT FULL-NAME)  (SETQ FULL-NAME  (STRING DATUM))))))

 (DEFMETHOD PROCESS-OPTION ((SYSTEM VANILLA-SYSTEM) (KEY (EQL :SHORT-NAME)) &amp;REST DATA)
   (WITH-SLOTS (SHORT-NAME FULL-NAME) SYSTEM
     (DESTRUCTURING-BIND (DATUM) DATA
       (SETQ SHORT-NAME (STRING DATUM)))))

 (DEFMETHOD PROCESS-OPTION ((SYSTEM VANILLA-SYSTEM) (KEY (EQL :FULL-NAME)) &amp;REST DATA)
   (WITH-SLOTS (SHORT-NAME FULL-NAME) SYSTEM
     (DESTRUCTURING-BIND (DATUM) DATA
       (SETQ FULL-NAME (STRING DATUM)))))

  .
  .
  .

 (DEFMETHOD PROCESS-OPTION ((SYSTEM VANILLA-SYSTEM) (KEY T) &amp;REST DATA)
   (ERROR "The option ~S is not known to ~S.~%Data: ~S"
          KEY SYSTEM DATA))
</pre>

<p>
Также обратите внимание, что в последнем из этих методов вызов 
Lisp Machine <code>COPYLIST</code> (такой же, как Common Lisp <code>COPY-LIST</code>)
не требуется, поскольку оставшиеся(rest) списки Common Lisp уже выделены в куче;
Lisp Machine использовала по умолчанию выделение в стеке для оставшихся(rest) списков,
поэтому было бы целесообразно явно указывать аргументы <code>COPYLIST</code>, которые
могут быть возвращены или сохранены в куче.
</p>

<p>
 --<i>KMP</i> 14-Jan-2001]
</p>
</font>

<p>
Предположительно, системы, наследуемые от <code>VANILLA-SYSTEM</code>
будут определяеть дополнительные методы
<code>:PROCESS-OPTION</code> для любых соответствующих им спецификаций.
</p>

<h3>Модульные Расширения</h3>

<p>
Учитывая базовые возможности, легко создавать модульные расширения. Обсуждаемая
ранее функция <code>HARDCOPY-SYSTEM</code>
может быть записана просто как:
</p>

<pre> (DEFUN HARDCOPY-SYSTEM (SYSTEM)
   (MAPC #'HARDCOPY-FILE (<font color="green">SYSDEF:</font>SOURCE-FILES SYSTEM)))
</pre>

<p>
Аналогично, можно написать средство для архивирования(сохранения) моментального 
снимка исходных файлов системы в другой каталог:
</p>

<pre> (DEFUN ARCHIVE-SYSTEM (SYSTEM ARCHIVE-DIRECTORY)
   (DOLIST (FILE (<font color="green">SYSDEF:</font>SOURCE-FILES SYSTEM))
     (COPY-FILE FILE ARCHIVE-DIRECTORY)))
</pre>

<p>
Нет причин, по которым пользователь должен сам писать такие вещи. В общем,
хорошо иметь системные библиотеки, которые имеют подобные вещи заранее.
Важно то, что если бы они не были изначально предоставлены, их  можно было
бы без проблем написать как расширения, потому что был выбран набор базовых
операций, который поддается модульному расширению.
</p>

<p>
Даже более изящные опции <code>DEFSYSTEM</code>,
такие как опция <code>:SELECTIVE</code>, выводятся на прямую
из этой модульности.  Например, суть опции
<code>:SELECTIVE</code> выражается как:
</p>

<pre> (LET ((PLAN (<font color="green">SYSDEF:</font>GENERATE-PLAN system :UPDATE)))
   (FORMAT T "~&amp;To update ~A:" system)
   (DOLIST (STEP PLAN)
     (<font color="green">SYSDEF:</font>EXPLAIN-ACTION system STEP))
   (UNLESS (NOT (Y-OR-N-P "Ready to go ahead?  "))
     (<font color="green">SYSDEF:</font>EXECUTE-PLAN system PLAN)))
</pre>

<p>
Вариации тоже просты. Например, пошаговые запросы могут быть выполнены
с помощью:
</p>

<pre> (DOLIST (STEP (<font color="green">SYSDEF:</font>GENERATE-PLAN system :UPDATE))
   (<font color="green">SYSDEF:</font>EXPLAIN-ACTION system STEP)
   (UNLESS (NOT (Y-OR-N-P "OK? "))
     (<font color="green">SYSDEF:</font>EXECUTE-ACTION system STEP)))
</pre>

<h3>Системы с Простыми Зависимостями</h3>

<p>
До сих пор, мало что было сказано, о том, какая информация должна входить в раздел 
параметров формы <code>DEFINE-SYSTEM</code>.
</p>

<p>
В простейшем случае всё, что мы могли бы указать, это набор
задействованных файлов. Так, например, мы могли бы представить
себе систему под названием <code>SIMPLE-SYSTEM</code>, в которой
раздел параметров представлял собой список файлов, так что
система, которую мы ранее указали с помощью:
</p>

<pre> (DEFINE-SYSTEM-SOURCES 'MYSYS
   "MACROS.LISP" "UTILITIES.LISP" "MAIN.LISP")
</pre>

<p>
теперь будет определяться как:
</p>

<pre> (DEFINE-SYSTEM MYSYS SIMPLE-SYSTEM
   "MACROS.LISP" "UTILITIES.LISP" "MAIN.LISP").
</pre>

<p>
Сравните простоту этого подхода со спецификацией <tt>MAKE</tt>:
</p>

<pre> (DEFINE-FOR-MAKE MYSYS
   ("main.bin" ("utilities.bin" "macros.bin" "main.lisp")
               (LOAD-IF-NOT-LOADED "macros.bin")
               (LOAD-IF-NOT-LOADED "utilities.bin")
               (LOAD (COMPILE-FILE "main.lisp")))
   ("utilities.bin" ("macros.bin" "utilities.lisp")
                    (LOAD-IF-NOT-LOADED "macros.bin")
                    (LOAD (COMPILE-FILE "utilities.lisp")))
   ("macros.bin" ("macros.lisp")
                 (LOAD (COMPILE-FILE "macros.lisp"))))
</pre>

<p>
или формой <code>DEFSYSTEM</code>:
</p>

<pre> (DEFSYSTEM MYSYS
   (:MODULE MACROS ("macros"))
   (:MODULE UTIL ("utilities"))
   (:MODULE MAIN ("main"))
   (:COMPILE-LOAD MACROS)
   (:COMPILE-LOAD-INIT UTIL (MACROS)
                       (:FASLOAD MACROS)
                       (:FASLOAD MACROS))
   (:COMPILE-LOAD-INIT MAIN (MACROS UTIL)
                       (:FASLOAD MACROS UTIL)
                       (:FASLOAD MACROS UTIL))).
</pre>

<p>
Система, определенная этой формой <code>DEFINE-SYSTEM</code>, является
объектом первого класса, который может исследоваться и управляться с помощью
функций абстракции предложенных в последнем разделе.
</p>

<h3>Система со Сложными Зависимостями</h3>

<p>
Теперь рассмотрим систему с набором макросов (in <tt>MACROS.LISP</tt>)
которые расширяются до вызовов функций в некотором пакете утилит
(в <tt>MACRO-SUPPORT.LISP</tt>).
Пользователи макропакета будут нарушать абстракцию, своим знанием, какая 
поддержка необходима для запуска пакета.
Тем не менее, с <code>DEFSYSTEM</code>, спецификация должна быть написана:
</p>

<pre> (DEFSYSTEM MYSYS
   (:MODULE MACROS ("macros"))
   (:MODULE MACRO-SUPPORT ("macro-support"))
   (:MODULE FOO ("foo"))
     .
     .
     .
   (:COMPILE-LOAD MACRO-SUPPORT)
   (:COMPILE-LOAD MACROS)
   (:COMPILE-LOAD-INIT FOO (MACROS)
                           (:FASLOAD MACROS)
                           (:FASLOAD MACRO-SUPPORT))
   ...)
</pre>

<p>
Пользователь заинтересованный в абстракции, может возразить против явного
указания зависимости <code>FOO</code> от <code>MACRO-SUPPORT</code>.
Конечно, пользователи <code>DEFSYSTEM</code>
жаловались, что это отсутствие абстракции делает очень большие системы очень трудно
определимыми и поддериваемыми с помощью <code>DEFSYSTEM</code>.
</p>

<p>
Вооружившись нашим новым предложением <code>DEFINE-SYSTEM</code>, можно было бы
разработать новую систему обозначений, чтобы справиться с ситуацией.  
Мы могли бы, например, предложить нотацию, где вместо того, чтобы явно
сказать "<code>FOO</code> зависит от
<code>MACRO-SUPPORT</code>" (как это происходит в <code>DEFSYSTEM</code>), 
мы могли бы сказать "Использование <code>MACROS</code> вызывает небходимость
в <code>MACRO-SUPPORT</code>."  Такая запись может выглядеть так:
</p>

<pre> (DEFINE-SYSTEM MYSYS MODULAR-SYSTEM
   (:MODULE MACRO-SUPPORT ("macro-support"))
   (:MODULE MACROS ("macros")
    (:CAUSES
     (:NEEDS
      (:INSTANTIATE MACRO-SUPPORT))))
   (:MODULE FOO ("foo")
    (:NEEDS
     (:UPDATE MACROS)))
   ...)
</pre>

<p>
Спорить за или против какой-то конкретной новой нотации не является смыслом
этой статьи. Реальная точка зрения состоит в том, что предлагаемая структура
обеспечивает возможность введения альтернативных обозначений таким образом,
чтобы это не мешало существующим обозначениям и инструментам. Существующие
инструменты могут корректно работать с системами, созданными с использованием
новых обозначений, таких как эта, потому что стандартизировано функциональное
поведение систем, а не обозначений.
</p>

<p>
<a name="ref-Robbins-84">В </a> <a href="#Robbins-84">[Robbins 84]</a>,
предлагается еще одна нотация (сопровождающая инструмент под названием <tt>BUILD</tt>)
для указания информации о зависимостях модуля. Хотя абстракции данных, предложенная
в этой статье, не были разработаны с учетом требований <tt>BUILD</tt>, они все равно
кажутся уместными для поддержки. Если бы предлагаемая струкутра уже существовала,
Robbins-у вероятно, было бы значительно проще экспериментировать с этими новыми
обозначениями.
</p>

<h3>Системы с Уникальными/своеобразными("Idiosyncratic") Зависимостями</h3>

<p>
Некоторые системы могут иметь очень сложные файловые зависимости. Например,
в некоторых случаях код мог эволюционировать таким образом, который требует
загрузки более ранней его копии, для поддержки его компиляции или установки.
Описание таких систем и того, как они должны быть построены, может потребовать
сложной системы обозначений.  Это приемлемо, только если это не влияет на 
простоту обозначений, используемых для описания простых систем.
</p>

<p>
Некоторые пользователи считают, что сложность <code>DEFSYSTEM</code>
связана с тем фактом, что одни и те же нотационные средства должны
испольозваться для всех типов систем, как простых, так и сложных. В этом
новом предложении системы могут быть классифицированы на различные виды,
каждый из которых имеет свои собственные обозначения. Мы проилюстрировали,
что для простых систем может протребоваться только указание задействованных
файлов и ничего больше, в то время как некоторые сложные системы могут быть
определены с точки зрения межфайловых зависимостей.
</p>

<p>
Однако для полностью общего случая, может быть разработана специальная нотация "one-shot"
"убивающая одним выстрелом двух(всех) зайцев", чтобы справиться с конкретными потребностями
сложных ситуаций, которые еще недостаточно понятны, чтобы обрабатываться более стандартными
нотациями. Например,
</p>

<pre> (DEFFLAVOR HAIRY-SYSTEM () (VANILLA-SYSTEM))

 (DEFMETHOD (HAIRY-SYSTEM :CASE :GENERATE-PLAN :UPDATE) ()
   '((:LOAD "Foo")
     (:COMPILE "Foo") ;Needs self to compile
     (:LOAD "Foo")
     (:LOAD "Bar")))

 (DEFINE-SYSTEM MY-HAIRY-SYSTEM HAIRY-SYSTEM) ;needs no options

 (<font color="green">SYSDEF:</font>EXECUTE-PLAN (SYSTEM 'MY-HAIRY-SYSTEM) :UPDATE)
</pre>

<font color="green">
<p>
[Для лучшей стилистической совместимости с другими такими операторами в Common Lisp, лучшим именем
для функции, которую мы назвали <code>SYSTEM</code> было бы <code>FIND-SYSTEM</code> или 
 <code>FIND-SYSTEM-NAMED</code>.  В <a href="#appendix-c">Приложении C</a>, мы использовали последнее.
<br>
 --<i>KMP</i> 21-Jan-2001]
</p>
</font>

<p>
Небольшое обобщение этой идеи приводит к другому типу системы, которая позволяет 
сопровождающему системы явно указывать, как обрабатывать каждый вид запроса 
<code>:GENERATE-PLAN</code>  :
</p>

<pre> (DEFFLAVOR PREPLANNED-SYSTEM ((FILES '())
                               (PLANS '()))
            (VANILLA-SYSTEM))

 (DEFMETHOD (PREPLANNED-SYSTEM :PROCESS-OPTIONS) (OPTIONS)
   (SETQ FILES (CAR OPTIONS))
   (SETQ PLANS (CDR OPTIONS)))

 (DEFMETHOD (PREPLANNED-SYSTEM :GENERATE-PLAN) (OPERATION)
   (LET ((P (ASSQ OPERATION PLANS)))
     (COND (P (CDR P))
           (T (FERROR "No plan for operation ~S" OPERATION))))).
</pre>

<p>
Сделав это, можно переписать ту же систему:
</p>

<pre> (DEFINE-SYSTEM MY-HAIRY-SYSTEM PREPLANNED-SYSTEM
                ("Foo" "Bar")
   (:UPDATE
     (:LOAD "Foo")
     (:COMPILE "Foo") ;Needs self to compile
     (:LOAD "Foo")
     (:LOAD "Bar"))
   ...).
</pre>

<p>
Эта нотация имеет некоторые черты пакетных файлов, обсуждавшихся ранее, но
гораздо лучше интегрируется с существующими инструментами.  Пользователи
системы могут загрузить или скомпилировать её, не зная, как она была определена.
Позже, если системные зависимости изменились или появилась новая нотация,
системная спецификация может быть изменена без уведомления пользователей.
</p>

<h3>Системы с Зависимостями, которые будут определены Компилятором</h3>

<p>
Некоторые люди возражают против идеи, что язык описания систем вообще нужен.
Они утверждают, что компилятор должен каким-то образом иметь возможность
выводить зависимости компиляции, распознавая и записывая предположения,
сделанные во время компиляции.
</p>

<p>
Этот вид вывода не является полностью надежным, поскольку компиляторы не всегда
могут точно определить зависимости компиляции, вызываемые изменениями состояния
глобальной среды во время компиляции.  Проблема связана с наличием в  Lisp мощных
примитивов, таких как <code>EVAL-WHEN</code>
и общей способностью макросов читать или изменять глобальное состояние во время
компиляции.
</p>

<p>
Чтобы увидеть проблему, рассмотрим управляемый данными механизм макросов,
такой как следующий, который поддерживает свое состояние как в компиляторе,
так и в среде во время выполнения:
</p>

<table width="80%" border="1">
<tbody><tr><td>
<pre>
   .
   .
   .
 (DEFUN EXPAND-DEFINITION (OP NAME BODY)
   (SELECTQ OP
     ((DEFINE) ...)
       .
       .
       .
     (OTHERWISE ...)))
   .
   .
   .
</pre>
</td></tr>
</tbody><caption align="bottom"><tt>A.LISP</tt></caption>
</table>

<table width="80%" border="1">
<tbody><tr><td>
<pre>
   .
   .
   .
 (DEFMACRO DEFINE (NAME .  BODY)
   (EXPAND-DEFINITION 'DEFINE NAME BODY))
   .
   .
   .
</pre>
</td></tr>
</tbody><caption align="bottom"><tt>B.LISP</tt></caption>
</table>

<table width="80%" border="1">
<tbody><tr><td>
<pre>
   .
   .
   .
 (DEFINE FOO ...)
   .
   .
   .
</pre>
</td></tr>
</tbody><caption align="bottom"><tt>C.LISP</tt></caption>
</table>

<p>
Если определение <code>EXPAND-DEFINITION</code> изменилось,
его, очевидно, придется перекомпилировать.  С другой стороны, определение
<code>DEFINE</code>, хотя оно напрямую относится к <code>EXPAND-DEFINITION</code>,
не зависит от изменения <code>EXPAND-DEFINITION</code>.
Поэтому <tt>A.LISP</tt> и <tt>C.LISP</tt> придется перекомпилировать, а
<tt>B.LISP</tt> - нет.
</p>

<p>
Однако, чтобы усложнить ситуацию, предположим, что вместо приведенного
выше определения, <code>EXPAND-DEFINITION</code> было определено
следующим образом:
</p>

<pre> (DEFUN EXPAND-DEFINITION (OP NAME BODY)
   (FUNCALL (GET OP 'EXPANDER) NAME BODY))
</pre>

<p>
В этом случае, казалось бы не связанное изменение, такое как изменение определения
в другом месте, такое как:
</p>

<pre> (DEFUN (:PROPERTY DEFINE EXPANDER) (NAME BODY) ...)
</pre>

<p>
может повлиять на расширение <code>FOO</code>,
что приведет к необходимости перекомпиляции <tt>C.LISP</tt>.
</p>

<p>
Может возникнуть соблазн предположить, что компилятор заметит, что вторым аргументом
 <code>GET</code> в <code>EXPAND-DEFINITION</code>
является константный символ <code>EXPANDER</code> и что функция, хранящаяся в
свойстве <code>EXPANDER</code> была изменена.
Некоторые особые случаи могут быть обработаны таким образом, но в целом прорблема
может стать сколь угодно сложной, и правильный анализ может быть не вычисляем.
Рассмотрим трудности, необходимые для понимания последствий даже:
</p>

<pre> (EVAL-WHEN (EVAL COMPILE)
   (DEFUN DEFINE-EXPANDER (NAME BODY) ...)
   (DEFUN FOO-EXPANDER ...)
     .
     .
     .
   (MAPC #'(LAMBDA (X Y) (PUTPROP X Y 'EXPANDER))
         '(DEFINE FOO ...)
         '(DEFINE-EXPANDER FOO-EXPANDER ...))).
</pre>

<p>
Это то, что мы могли бы представить себе достаточно продвинутым компилятором,
но мы можем быть не готовы заплатить за накладные расходы, необходимые для 
вывода(определения) информации.  Проблемы производительности особенно важны
в системах, которые должны работать в интерактивном режиме и учитывать вмешательство
пользователя, постепенную разработку и переопределение среды выполнения. Стоимость
указания программистами зависимостей для программиста может быть очень дешевой по
сравнению со стоимостью того, что он вынужден сидеть без дела, ожидая пока машина
выведет их.
</p>

<p>
Обнаружение зависимостей времени загрузки также затрудняется из-за способности
программиста включать неограниченные формы верхнего уровня в файл, выполняемый
во время загрузки.
</p>

<p>
Конечно, реальная проблема, вероятно, заключается в том, что неограниченнные
изменения в глобальном состоянии не совсем понятны и могут даже быть плохой
идеей. Есть много активных усилий по разработке языков, которые стремятся 
показать, что языки использующие глобальное состояние, должны быть просто
выброшены в окно. Однако, пока такие усилия не увенчаются успехом, проблема
определения и управления большими системами будет оставаться важной.
</p>

<p>
И если когда-нибудь случиться, что языки программирования станут достаточно
ограниченными, чтобы все зависимости можно было бы вывести механически, наши
абстракции данных все равно обеспечат необходимый интерфейс между новой 
технологией вывода зависимостей и стандартными утилитами обслуживания для
загрузки, компиляции, печати, <i>и т.д.</i> Единственное, что мы можем ожидать,
это изменение в том, что сложные обозначения для описания систем могут уступить
место более простым.  Таким образом, даже если информация о зависимости была
сложной, в конечном итоге нужно было написать:
</p>

<pre> (DEFINE-SYSTEM MYSYS ULTIMATE-SYSTEM
   "MACROS.LISP" "UTILITIES.LISP" "MAIN.LISP"))
</pre>

<p>
и остальная информация может быть выведена механически.
</p>

<p>
Такой синтаксис может быть достаточно привлекательным, чтобы люди захотели
переписать все свои системы, используя его. Но тем временем, в то время как
люди конвертировали определения своих систем, чтобы использовать ту более 
простую нотацию, системы, определенные с использованием более старых нотаций,
могли бы продолжать работать правильно и совместимо под защитой наших механизмов
абстракции.
</p>

<p>
В предыдущих примерах мы показали, как разрешить совместное сосуществование
нескольких нотаций в одной и той же среде, чтобы дать возможность сопровождающим
системы гибко выбирать нотацию, подходящую для конкретного приложения.  
Здесь мы видим вторую причину использования нескольких обозначений: для облегчения
перехода от одного поколения языков описания системы к следующему.
</p>

<h2>V. Резюме</h2>

<p>
Мы мотивировали потребность в инструментах определения системы, определили
некоторые критерии, которым должны удовлетворять такие инструменты, и предложили
набор инструментов, которые удовлетворяют этим критериям.
</p>

<p>
Инструменты обслуживания системы должны основываться на данных, что позволяет
создавать новые инструменты как расширения существующих инструментов, исключая
те же данные.
</p>

<p>
Инструменты должны быть общего назначения, позволяющие создавать произвольные
типы систем из них. Однако, необходимость в общности не должна заражать нотацию,
что делает общие случаи слишком сложными для удобного определения нотаций.
</p>

<p>
Мы предложили, что эти цели были достигнуты с помощью подхода на основе
протокола.  Предлагаемый подход исключает конкретный синтаксис, используемый
для определения системы, и подчеркивает важность создания системы с четко
определенным функциональным поведением.
</p>

<p>
Предложение предусматривает создание систем, которые удовлетворяют заранее
определенному функциональному протоколу. Этот протокол позволяет утилитам
обслуживания системы получать доступ к спецификации системы и манипулировать
ею. Предложенные функции предоставляют интерфейс для поиска файлов, из которых
состоит система, и запроса о том, как выполнять операции обслуживания системы,
такие как редактирование, компиляция, создание экзепляров и печать.
</p>

<p>
Поскольку системе может быть предложено создать план для операции, такой как
компиляция, без фактического выполнения операции, можно написать программы,
которые проверяют план, возможно оптимизируют его или представляют его 
для интерактивного утверждения, прежде чем выполнить его.
</p>

<p>
Предложение также предусматривает возможность одновременного использования
нескольких языков для описания системы в одной и той же среде.
Эта возможность позволяет сопровождающему системы свободно выбирать нотацию,
которая подходит для данного приложения, не требуя, чтобы те, кому необходимо
манипулировать(компилировать, загружать и  <i>т.д.</i>) системой, знали, какая
нотация использовалась.
</p>

<p>
Приведены примеры, чтобы проилюстрировать как различные функции этого приложения
работают вместе в различных ситуациях, чтобы обеспечить полезность и гибкость.
</p>

<h2 align="center"><i>Рекомендации/Ссылки</i></h2>

<dl>
<dt><a name="Bonanni-77">[Bonanni 77]</a></dt>
<dd>
<p>
<b>L. E. Bonanni</b> and <b>A. L. Glasser</b>, "SCCS/PWB User's Manual,"
Bell Laboratories, Murray Hill, NJ, November, 1977.
<br>
<font color="green">
[Auxiliary reading not specifically indicated in paper, but intended as
background for Unix <code>MAKE</code>.<br>
 --<i>KMP</i> 14-Jan-2001]
</font>
</p>
</dd>

<dt><a name="Feldman-78">[Feldman 78]</a></dt>
<dd>
<p>
<b>S. I. Feldman</b>, "Make--A Program for Maintaining Computer
Programs," Bell Laboratories, Murray Hill, NJ, August, 1978.
<br>
<font color="green">
<a href="#ref-Feldman-78">[Click to return to reference.]</a>
</font>
</p>
</dd>

<dt><a name="Mackinlay-84">[Mackinlay 84]</a></dt>
<dd>
<p>
<b>J. Mackinlay</b> and <b>M. Genesereth</b>, "Expressiveness of
Languages," <i>Proceedings of the National Conference on Artificial
Intelligence</i>, University of Texas, Austin, TX, August, 1984.
<br>
<font color="green">
<a href="#ref-Mackinlay-84">[Click to return to reference.]</a>
</font>
</p>
</dd>

<dt><a name="Rees-84">[Rees 84]</a></dt>
<dd>
<p>
<b>J. Rees</b>, <b>N. Adams</b> and <b>J. Meehan</b>,
<i>The T Manual</i>, Computer Science
Department, Yale University, New Haven, CT, January, 1984.
<br>
<font color="green">
<a href="#ref-Rees-84">[Click to return to reference.]</a>
</font>
</p>
</dd>

<dt><a name="Robbins-84">[Robbins 84]</a></dt>
<dd>
<p>
<b>R. Robbins</b>, <i>BUILD--A System Construction Tool</i>, Working Paper
261, Artificial Intelligence Laboratory, MIT, Cambridge, MA, 1984.
<br>
<font color="green">
<a href="#ref-Robbins-84">[Click to return to reference.]</a>
</font>
</p>
</dd>

<dt><a name="Steele-84">[Steele 84]</a></dt>
<dd>
<p>
<b>G. L. Steele, Jr.</b>, <i>Common LISP: The Language</i>, Digital Press,
Burlington, MA, 1984.
<br>
<font color="green">
[Auxiliary reading not specifically indicated in paper.  I have no idea why,
since Common Lisp is not mentioned in the paper!<br>
 --<i>KMP</i> 14-Jan-2001]
</font>
</p>
</dd>

<dt><a name="Theriault-83">[Theriault 83]</a>
</dt>
<dd>
<p>
<b>D. G. Theriault</b>, <i>Issues in the Design and Implementation of
Act2</i>, Technical Report 728, Artificial Intelligence Laboratory, MIT,
Cambridge, MA, June, 1983.
<br>
<font color="green">
<a href="#ref-Theriault-83">[Click to return to reference.]</a>
</font>
</p>
</dd>

<dt><a name="Weinreb-81">[Weinreb 81]</a></dt>
<dd>
<p>
<b>D. Weinreb</b> and <b>D. Moon</b>, <i>Lisp Machine Manual</i>,
Fourth Edition,
MIT Artificial Intelligence Laboratory, July, 1981.
<br>
<font color="green">
<a href="#ref-Weinreb-81">[Click to return to reference.]</a>
</font>
</p>
</dd>
</dl>

<h2 align="center"><i>Благодарности</i></h2>

<p>
Dan Brotsky, Dan Carnese, Henry Lieberman, Chuck Rich, Patrick Sobalvarro,
Dick Waters, and Dan Weld read drafts of this paper, providing support and
commentary.  Comments by Waters and Brotsky, who read multiple drafts,
played an especially important role in improving the clarity and
organization of my presentation.
</p>

<p>
Stephen Gildea provided useful background documentation and answered
questions about Unix and its <tt>MAKE</tt> facility.
</p>

<hr width="50%" align="center">

<ol>
<li>
<p>
<a name="footnote1">
Unix is a trademark of Bell Labs.
</a>
<br>
<font color="green">
This footnote was referenced once from the Abstract and once from the
main paper body:<br>
<a href="#footref1a">[Click to return to first reference.]</a><br>
<a href="#footref1b">[Click to return to second reference.]</a>
</font>
</p>
</li>

<li>
<p>
<a name="footnote2">
In general, notations must be chosen with extreme care;</a> an ill-chosen
notation can have a very adverse effect on specifications that use it,
making them seem to imply things which are in fact false. 
<a name="ref-Mackinlay-84">
For a more complete discussion of such issues,</a>
see <a href="#Mackinlay-84">[Mackinlay 84]</a>.
<br>
<font color="green">
<a href="#footref2">[Click to return to reference.]</a>
</font>
</p>
</li>

<li>
<p>
<a name="footnote3">
In <tt>Lisp Machine Lisp</tt>,</a>
symbols preceded by a colon are "keywords"
interned in a canonical "keyword package." By special decree, keywords are
self-quoting (<i>i.e.,</i> bound to themselves).
Hence, <code>':FOO</code> and <code>:FOO</code> evaluate to
the same thing, <code>:FOO</code>.
<br>
<font color="green">
<a href="#footref3">[Click to return to reference.]</a>
</font>
</p>
<p>
<font color="green">
[In Maclisp, the predominant language of the time, 
there were no packages
and colon was an alphabetic character.  
The style of <tt>Lisp Machine Lisp</tt> 
mentioned here later became the style of Common Lisp, so this footnote 
probably seems somewhat trivial now.<br>
 --<i>KMP</i> 14-Jan-2001]
</font>
</p>
</li>

<li>
<p>
<a name="footnote4">
This example is taken directly from a real program system developed by
the MIT Programmer's Apprentice group.  The full definition is much longer,
describing the relations between about 90 files, grouping them into about
50 logical modules.
</a>
<br>
<font color="green">
<a href="#footref4">[Click to return to reference.]</a>
</font>
</p>
</li>
</ol>

<hr>

<h2><a name="appendix-a">Приложение A: Примеры</a></h2>

<p>
Эти примеры приведены для иллюстрации того, как код из <a href="#appendix-b">приложения B</a> 
может использоваться на практике.
</p>

<h3>Пример 1</h3>

<p>
Рассмотрим систему состоящую из трех файлов, <tt>"foo"</tt>, <tt>"bar"</tt>,
и <tt>"baz"</tt>.  Такая система может быть удобно описана в форме
<code>DEFINE-SYSTEM</code> с испольованием обозначения 
<code>SIMPLE-SYSTEM</code> следующим образом:
</p>

<pre> (define-system Example1 simple-system
   "oz:ps:&lt;zippy&gt;.foo.lisp" "bar.lisp" "baz.lisp")
</pre>

<p>
Она также может быть описана с использованием нотации <code>MODULAR-SYSTEM</code>.
Например,
</p><p>

</p><pre>(define-system Example1 modular-system
  (:module m1 "oz:ps:&lt;zippy&gt;foo.lisp")
  (:module m2 "bar.lisp"
   (:needs (:instantiate m1)
           (:update m1)))
  (:module m3 "baz.lisp"
   (:needs (:instantiate m2)
           (:update m2))))
</pre>

<p>
В этом случае нотация <code>SIMPLE-SYSTEM</code> очевидно предпочтительнее, так
как она проясняет простоту отношений между файлами.  В других случаях, однако, 
<code>SIMPLE-SYSTEM</code> не будет достаточно мощной, чтобы выразить межмодульные
отношения, как будет показано в нашем следующем примере.
</p>

<h3>Пример 2</h3>

<p>
Существует файл с именем <tt>"MACROS"</tt>, который требует поддержки
во время компиляции от <tt>"MACRO-HELPERS"</tt>.  Резултат расширения
этих макросов требует поддержки со стороны <tt>"MACRO-SUPPORT-1"</tt>
и <tt>"MACRO-SUPPORT-2"</tt> во время компиляции и <tt>"BASIC"</tt> во
время выполнения.  Пользователи <tt>"MACROS"</tt> не должны знать об
этих файлах поддержки, поэтому мы хотим, чтобы каждый раз, когда модуль
говорит, что ему нужен <tt>"MACROS"</tt>, все другие  зависимости
добавлялись неявно.
</p>

<p>
Есть файл под названием <tt>"META-MACROS"</tt>. 
Макросы в этом файле преобразуются в вызовы макросов в <tt>"MACROS"</tt>, 
хотя его пользователь не должен знать об этом.
</p>

<p>
Существует файл с именем <tt>"UTILITIES"</tt> которому требуется <tt>"MACROS"</tt> во время
компиляции и <tt>"BASE"</tt> во время выполнения.  Он явно использует функции из <tt>"BASE"</tt>,
поэтому должен указывать явную зависимость от него, даже если случается, что  <tt>"MACROS"</tt>
предоставляет явную зависимость.
</p>

<p>
Существует файл с именем <tt>"MAIN"</tt> который зависит от 
<tt>"UTILITIES"</tt> во время выполнения и
<tt>"META-MACROS"</tt> во время компиляции.
</p>

<pre>(define-system Example2 modular-system
  (:full-name "The Second Example")
  (:module base "OZ:PS:&lt;FOO&gt;BASIC.LISP")
  (:module macro-helpers "OZ:PS:&lt;FOO&gt;MACRO-HELPERS.LISP")
  (:module macros "OZ:PS:&lt;FOO&gt;MACROS.LISP"
   (:needs
    (:instantiate macro-helpers))
   (:causes
    (:needs
     (:instantiate base)
     (:update macro-support))))
  (:module macro-support ("OZ:PS:&lt;FOO&gt;MACRO-SUPPORT-1.LISP"
                          "OZ:PS:&lt;FOO&gt;MACRO-SUPPORT-2.LISP"))
  (:module meta-macros "OZ:PS:&lt;FOO&gt;META-MACROS.LISP"
   (:causes
    (:needs
     (:update macros))))
  (:module util "OZ:PS:&lt;FOO&gt;UTILITIES.LISP"
   (:needs
    (:update macros)
    (:instantiate base)))
  (:module main "OZ:PS:&lt;FOO&gt;MAIN.LISP"
   (:needs
    (:instantiate util)
    (:update meta-macros))))
</pre>

<p>
Эквивалент в <code>DEFSYSTEM</code> будет:
</p>

<pre>(defsystem Example2
  (:short-name "EXAMPLE2")
  (:full-name  "The Second Example")

  (:module BASE ("OZ:PS:&lt;FOO&gt;BASIC.LISP"))
  (:module MACRO-HELPERS ("OZ:PS:&lt;FOO&gt;MACRO-HELPERS.LISP"))
  (:module MACROS ("OZ:PS:&lt;FOO&gt;MACROS.LISP"))
  (:module MACRO-SUPPORT ("OZ:PS:&lt;FOO&gt;MACRO-SUPPORT-1.LISP"
                          "OZ:PS:&lt;FOO&gt;MACRO-SUPPORT-2.LISP"))
  (:module META-MACROS ("OZ:PS:&lt;FOO&gt;META-MACROS.LISP"))
  (:module UTILITIES ("OZ:PS:&lt;FOO&gt;UTILITIES.LISP"))
  (:module MAIN ("OZ:PS:&lt;FOO&gt;MAIN.LISP"))
  (:compile-load BASE)
  (:compile-load MACRO-HELPERS)
  (:compile-load MACROS NIL (:FASLOAD MACRO-HELPERS))
  (:compile-load MACRO-SUPPORT)
  (:compile-load META-MACROS)
  (:compile-load-init UTIL (MACRO-SUPPORT MACROS)
                           (:FASLOAD MACRO-SUPPORT MACROS)
                           (:FASLOAD BASE))
  (:compile-load-init MAIN (:MACRO-SUPPORT MACROS META-MACROS)
                           (:FASLOAD MACRO-SUPPORT MACROS META-MACROS)
                           (:FASLOAD UTIL BASE)))
</pre>

<p>
Однако, обратите внимание, что даже в этом небольшом примере мы можем
видеть характерную пирамидальную форму, которую склонны принимать
предложения зависимостей  <tt>DEFSYSTEM</tt>.
</p>

<hr>

<h2><a name="appendix-b">Приложение B: Код</a></h2>

<font color="green">
<p>
[Смотрите так же <a href="#appendix-c">Приложение C</a>, которое представляет собой попытку
перевести этот код в нечто более похожее на Common Lisp.
<br>
 --<i>KMP</i> 21-Jan-2001]
</p>
</font>

<pre>;;; -*- Mode:LISP; Package:USER; Base:10; Fonts:MEDFNB -*-

;;;; System

;;; SYSTEM
;;;
;;; Any flavor which claims to satisfy the SYSTEM protocol should
;;; include this flavor in its component flavors list.

(defflavor system () ()
  (:required-methods
     :process-options
     :process-option
     :source-files
     :generate-plan
     :explain-plan
     :execute-plan
     :explain-action
     :execute-action))

;;;; Vanilla System

;;; VANILLA-SYSTEM
;;;
;;; A vanilla system knows about names and how to process options,
;;; but has no interesting options it is willing to process that would
;;; make it useful as something to instantiate.

(defflavor vanilla-system ((short-name nil) (full-name nil)) (system)
  (:method-combination (:case :base-flavor-last
                          :generate-plan
                          :process-option
                          :explain-action
                          :execute-action))
  :settable-instance-variables)

;;; :NAME (to VANILLA-SYSTEM)
;;;
;;; Returns the name of the system
;;; Long name is preferred over short name where both are available.

(defmethod (vanilla-system :name) () (or full-name short-name))

;;; :PRINT-SELF ...  (to VANILLA-SYSTEM)
;;;
;;; For debugging convenience,
;;; (PRIN1 mysys) types something like: #&lt;SYSTEM "My System" 343324&gt;
;;; (PRINC mysys) types something like: My System

(defmethod (vanilla-system :print-self) (stream level prin1?  &amp;rest ignore)
  level :ignored
  (let ((my-name (send self :name)))
    (cond ((not prin1?)  (format stream "~A" my-name))
          (t
           (format stream "#&lt;~S ~A ~O&gt;"
                   (typep self) my-name (%pointer self))))))

;;; :DESCRIBE (to VANILLA-SYSTEM)
;;;
;;; Does that part of the explanation relevant to the flavor.
;;; Other flavors mixing this in should use :AFTER or :BEFORE
;;; daemons to modify this method.

(defmethod (vanilla-system :describe) ()
  (format t "~2&amp;~A is a system of type ~S.~%" self (typep self))
  self)

;;;; Options Facility

;;; :PROCESS-OPTIONS options (to VANILLA-SYSTEM)
;;;
;;; Maps across the given options, digesting them.

(defmethod (vanilla-system :process-options) (options)
  (dolist (data options)
    (lexpr-send self :process-option (car data) (cdr data)))
  self)

;;; :PROCESS-OPTION opt-name .  opt-args (to VANILLA-SYSTEM)
;;;
;;; :NAME Sets defaults for all name types.
;;; :SHORT-NAME Sets the short name (overrides :NAME if given).
;;; :LONG-NAME Sets the long name (overrides :NAME if given).
;;; otherwise Signals an error.

(defmethod (vanilla-system :case :process-option :name) (data)
  (if (not short-name) (setq short-name (string data)))
  (if (not full-name) (setq full-name (string data))))

(defmethod (vanilla-system :case :process-option :short-name) (data)
  (setq short-name (string data)))

(defmethod (vanilla-system :case :process-option :full-name) (data)
  (setq full-name (string data)))

(defmethod (vanilla-system :otherwise :process-option) (key &amp;rest data)
  (ferror "The option ~S is not known to ~S.~%Data: ~S"
          key self (copylist data)))

;;;; Planning/Executing Actions

;;; :GENERATE-PLAN action (to VANILLA-SYSTEM)
;;;
;;; This method returns abstract information about how to perform
;;; a specified ACTION. The reply is in the form of a list of the
;;; form ((MSG1 .  MSG-ARGS1) (MSG2 .  MSG-ARGS2) ...), such that
;;; sending each MSG (with the given MSG-ARGS) to the object in
;;; order will accomplish the action in question.
;;;
;;; :UPDATE How to compile (or otherwise update) the system,
;;; :INSTANTIATE How to load (or otherwise instantiate) the system.
;;; otherwise An error results if the action isn't defined.

(defmethod (vanilla-system :otherwise :generate-plan) (key &amp;rest data)
  (ferror "The object ~S does not know how to ~S.~%Data: ~S"
          self key (copylist data)))

;;; :EXECUTE-PLAN plan (to VANILLA-SYSTEM)
;;;
;;; The steps of the plan are executed.
;;;
;;; PLAN may be either a plan name (a symbol) or a list of steps
;;; such as that returned by a :GENERATE-PLAN message.

(defmethod (vanilla-system :execute-plan) (plan)
  (cond ((symbolp plan)
         (send self :execute-plan (send self :generate-plan plan)))
        (t
         (dolist (step plan)
           (lexpr-send self :execute-action step))))
  self)

;;; :EXPLAIN-PLAN plan (to VANILLA-SYSTEM)
;;;
;;; The steps of the PLAN are explained.
;;;
;;; PLAN may be either a plan name (a symbol) or a list of steps
;;; such as that returned by a :GENERATE-PLAN message.

(defmethod (vanilla-system :explain-plan) (plan)
  (cond ((symbolp plan)
         (send self :explain-plan (send self :generate-plan)))
        (t
         (dolist (step plan)
           (lexpr-send self :explain-action step))))
  self)

;;; :EXECUTE-ACTION name .  args (to VANILLA-SYSTEM)
;;; :EXPLAIN-ACTION name .  args (to VANILLA-SYSTEM)
;;;
;;; Sending :EXECUTE-ACTION causes a given action to occur.
;;;
;;; Sending :EXPLAIN-ACTION describes what a given action would
;;; do if performed.
;;;
;;; These messages are handled by :CASE method dispatch.
;;;
;;; :LOAD Load a (Lisp) file.
;;; :COMPILE Compile a (Lisp) file.
;;; Otherwise an error.

(defmethod (vanilla-system :case :execute-action :load (file)
  (load file))

(defmethod (vanilla-system :case :execute-action :compile) (file)
  (compiler:compile-file file))

(defmethod (vanilla-system :otherwise :execute-action) (key &amp;rest data)
  (ferror "The action ~S is not known to ~S.~%Data: ~S"
          key self (copylist data)))

;;; :EXPLAIN-ACTION name .  args (to VANILLA-SYSTEM)
;;;
;;; If the action is valid but a description wasn't available, try
;;; to conjure up a plausible description based on the name of the
;;; action and its arguments.

(defmethod (vanilla-system :otherwise :explain-action) (key &amp;rest data)
  (cond ((not (memq key (send self :execute-action :which-operations)))
         (ferror "The action ~S is not known to ~S, so can't describe it.~
                ~%Data: ~S"
                 key self (copylist data)))
        (t (format t "~&amp;~A~@[ ~{~A~^, ~}.~]~%"
                   (string-capitalize-word key) data))))

;;;; Simple System

;;; SIMPLE-SYSTEM
;;;
;;; A simple system is a system which has left-to-right file
;;; dependencies.

(defflavor simple-system ((source-files '())) (vanilla-system)
  :gettable-instance-variables)

;;; :AFTER :DESCRIBE (to SIMPLE-SYSTEM)
;;;
;;; Tacks on some information about the files which make up this system.

(defmethod (simple-system :after :describe) ()
  (format t "~&amp;It has source files~{~&lt;~%~1:; ~S~&gt;~^,~}.~%" source-files))

;;; :PROCESS-OPTIONS (to SIMPLE-SYSTEM)
;;;
;;; The only options allowed to a simple system is a list of file
;;; names with left-to-right ordering dependencies.

(defmethod (simple-system :process-options) (options)
  (when options
    (setq source-files '())
    (let ((default-pathname (fs:merge-pathname-defaults (car options))))
      (dolist (file options)
        (setq default-pathname
              (fs:merge-pathname-defaults file default-pathname))
        (push default-pathname source-files))
      (setq source-files (nreverse source-files)))
    t))

;;; :GENERATE-PLAN :UPDATE (to SIMPLE-SYSTEM)
;;;
;;; To update this kind of system, one must compile and load each
;;; of its files in sequence.

(defmethod (simple-system :case :generate-plan :update) ()
  (mapcan #'(lambda (file)
              (list (list ':compile file)
                    (list ':load (send file :new-pathname
                                            :type :bin))))
          source-files))

;;; :GENERATE-PLAN :INSTANTIATE (to SIMPLE-SYSTEM)
;;;
;;; To instantiate this kind of system, one must simply load each
;;; of its files in sequence.

(defmethod (simple-system :case :generate-plan :instantiate) ()
  (mapcan #'(lambda (file)
              (list (list ':load
                          (send file :new-pathname :type :bin))))
          source-files))

;;;; Pre-Planned System

;;; PREPLANNED-SYSTEM
;;;
;;; A preplanned system is a system which has its plans for manipulation
;;; specified explicitly rather than inferred.

(defflavor preplanned-system ((files '())
                              (plans '()))
           (vanilla-system))

;;; :PROCESS-OPTIONS (to PREPLANNED-SYSTEM)
;;;
;;; The clauses in the DEFINE-SYSTEM for this kind of system are
;;; just (&lt;plan-name&gt; .  &lt;commands&gt;).

(defmethod (preplanned-system :process-options) (options)
  (setq files (car options))
  (setq plans (cdr options)))

;;; :GENERATE-PLAN (to PREPLANNED-SYSTEM)
;;;
;;; This does simple table-lookup to find the plan.

(defmethod (preplanned-system :generate-plan) (operation)
  (let ((p (assq operation plans)))
    (cond (p (cdr p))
          (t (ferror "No plan for operation ~S" operation)))))

;;;; Modular System

;;; MODULAR-SYSTEM
;;;
;;; A modular system is a system which allows specification of
;;; inter-module dependencies, both implicit and explicit.

(defflavor modular-system ((modules nil)) (vanilla-system)
  :initable-instance-variables
  :gettable-instance-variables
  :settable-instance-variables)

;;; :AFTER :DESCRIBE (to MODULAR-SYSTEM)
;;;
;;; When a modular system is described, we tack on information
;;; saying how many modules it has and then we ask each module
;;; to describe itself.

(defmethod (modular-system :after :describe) ()
  (let ((m-list (send self :modules)))
    (format t "~&amp;It has ~D module~:P:" (length m-list))
    (dolist (m m-list)
      (send m :describe))))

;;; :GET-MODULE name (to MODULAR-SYSTEM)
;;;
;;; Returns the component module with the given name (or NIL if none).

(defmethod (modular-system :get-module) (name)
  (dolist (m modules)
    (if (eq (send m :name) name) (return m))))

;;; :SOURCE-FILES
;;;
;;; Returns a list of the source files for the system.

(defmethod (modular-system :source-files) ()
  (apply #'append
         (mapcar #'(lambda (module)
                     (send module :source-files))
                 modules)))

;;; :PROCESS-OPTION :MODULE .  spec (to MODULAR-SYSTEM)
;;;
;;; Declares how to handle the :MODULE option.  Creates an object
;;; of type MODULE and lets it process the associated spec.

(defmethod (modular-system :case :process-option :module) (&amp;rest spec)
  (setq modules
        (nconc modules
               (ncons (make-instance 'module
                                     :system self
                                     :spec (copylist spec))))))

;;;; Module

;;; MODULE
;;;
;;; A module is a collection of files to be used as a building
;;; block for modular systems.

(defflavor module ((name nil)
                   (system nil)
                   (spec nil)
                   (source-files '())
                   (assertions '())
                   (needs '())
                   (causes '()))
           ()
  :initable-instance-variables
  :gettable-instance-variables
  :settable-instance-variables
  (:method-combination (:case :base-flavor-last :process-assertions)))

;;; :AFTER :INIT (to MODULE)
;;;
;;; See to it that if SPEC was given, it gets appropriately processed.

(defmethod (module :after :init) (&amp;rest ignore)
  (send self :process-spec spec))

;;; :PRINT-SELF ...  (to MODULE)
;;;
;;; For debugging convenience.
;;; (PRIN1 mod) types something like: #&lt;Module MYSYS*MOD1 234567&gt;
;;; (PRINC mod) types something like: MOD1

(defmethod (module :print-self) (stream level prin1?  &amp;rest ignore)
  level :ignored
  (let ((my-name (send self :name)))
    (cond ((not prin1?)  (format stream "~A" my-name))
          (t
           (format stream "#&lt;~S ~@[~A*~]~:[Anonymous~;~:*~A~] ~O&gt;"
                   (typep self)
                   (let ((sys (send self :system)))
                     (if sys (send sys :short-name)))
                   my-name
                   (%pointer self))))))

;;; :DESCRIBE (to MODULE)
;;;
;;; Details the source files and dependency information
;;; for the module.

(defmethod (module :describe) ()
  (format t "~2&amp; ~A~@[  ~{~%~A~^.~}~]~%" self source-files)
  (do ((n needs (cddr n)))
      ((null n))
    (format t "~&amp; ~S dependenc~@P: ~{~S~^, ~}.~%"
            (car n) (length (cadr n)) (cadr n)))
  (format t "~&amp;")
  self)

;;; :PROCESS-SPEC spec (to MODULE)
;;;
;;; Process the given SPEC absorbing relevant info.
;;;
;;; The NAME is only absorbed if name info isn't already set up.
;;; This is because :PROCESS-SPEC may be recursively called on others'
;;; assertion lists if there are included modules with specs of their
;;; own.  In such case, we want to accept their attributes, but not
;;; their names.
;;;
;;; The ASSERTIONS are processed next, because presumably they specify
;;; prerequisites for this module and any files they need loaded should
;;; get set up before we set up the files particular to this module.
;;;
;;; Finally, the FILES associated with this module are processed.

(defmethod (module :process-spec) (s)
  (when s
    (if (not name) (setq name (car s)))
    (send self :process-assertions (cddr s))
    (send self :process-files (cadr s))))

;;; :PROCESS-FILES files-list (to MODULE)
;;;
;;; Adds file info given in FILES-LIST to the module's master FILES list.

(defmethod (module :process-files) (files-list)
  (if (atom files-list) (setq files-list (list files-list)))
  (dolist (file files-list)
    (cond ((typep file 'fs:pathname)
           (setq source-files (nconc source-files (ncons file))))
          ((stringp file)
           (setq source-files (nconc source-files
                                     (ncons (fs:parse-pathname file)))))
          ((symbolp file)
           (send self :process-spec
                 (send (send system :get-module file) :spec)))
          (t
           (ferror "Bad object in file list: ~S - ~S" file self)))))

;;; :PROCESS-ASSERTIONS spec (to MODULE)
;;;
;;; Iterates across assertions, processing each.

(defmethod (module :process-assertions) (assertion-list)
  (dolist (assertion assertion-list)
    (lexpr-send self :process-assertion assertion)))

;;; :PROCESS-ASSERTION .  data (to MODULE)
;;;
;;; This method is used to process dependency assertions, etc.
;;; for the given module.  It uses case method dispatch:
;;;
;;; :NEEDS Declares need to instantiate modules at certain times.
;;; :CAUSES Declares assertions to be forwarded to the consumer.
;;; Otherwise an error.

(defmethod (module :case :process-assertions :needs) (&amp;rest data)
  (let ((pl (locf needs)))
    (dolist (item data)
      (let ((marker (car item)))
        (dolist (module-name (cdr item))
          (when (not (memq module-name (get pl marker)))
            (let ((m (send (send self :system) :get-module module-name)))
              ;; This may be overly conservative, but will work...
              (send self :process-assertions (send m :causes))
              (setf (get pl marker)
                    (nconc (get pl marker) (ncons module-name))))))))))

(defmethod (module :case :process-assertion :causes) (&amp;rest data)
  ;; Filtering this is technically unnecessary, but it will keep
  ;; redefinition from swamping us.
  (dolist (item data)
    (if (not (mem #'equal item causes))
        (setf causes (nconc causes (ncons item))))))

(defmethod (module :otherwise :process-assertions) (key &amp;rest data)
  (ferror "The ~S assertion is not known to ~S.~%Data: ~S"
          key self (copylist data)))

;;;; User Interface

;;; (CREATE-SYSTEM name type [options])
;;;
;;; Creates a system object of the given TYPE, initializing it with
;;; with the given NAME and OPTIONS. Returns the created object without
;;; storing it permanently anywhere.

(defun create-system (name type &amp;optional options)
  (let ((system (make-instance type)))
    (send system :process-option :name name)
    (send system :process-options options)
    system))

;;; (SYSTEM name)
;;;
;;; Gets the definition of some globally defined system object.

(defsubst system (name) (get name 'system))

;;; (DEFINE-SYSTEM name type .  options)
;;;
;;; Creates and initializes a system with the given name.
;;; Stores the definition globally for access later.

(defmacro define-system (name type &amp;body data)
  `(setf (system ',name)
         (create-system ',name ',type ',data)))

;;;; Utility Functions

(defun process-options (system options-alist)
  "Tells SYSTEM to process the given OPTIONS-ALIST."
  (send system :process-options options-alist))

(defun process-option (system option-name &amp;rest option-data)
  "Tells SYSTEM to process an individual option, given its NAME and DATA."
  (lexpr-send system :process-option option-name option-data))

(defun source-files (system)
  "Returns a list of the source files for SYSTEM."
  (declare (values files))
  (send system :source-files))

(defun plan (system operations)
  "Returns a list of ACTIONS (plan steps) for doing OPERATION."
  (declare (values actions))
  (send system :generate-plan operation))

(defun execute (system actions)
  "Tells SYSTEM to execute the given ACTIONS (plan steps)."
  (send system :execute-plan actions))

(defun explain (system actions)
  "Tells SYSTEM to explain the given ACTIONS (plan steps)."
  (send system :explain-plan actions))

(defun execute-action (system action)
  "Tells SYSTEM to execute the given ACTION (plan step)."
  (send system :execute-action action))

(defun explain-action (system action)
  "Tells SYSTEM to explain the given ACTION (plan step)."
  (send system :explain-action action))
</pre>

<font color="green">

<hr>

<h2><a name="appendix-c">Приложение C: Код Common Lisp</a></h2>

<p>
[Этот раздел был добавлен для веб переиздания. Код здесь был переведен на Common Lisp.  Тестирование
вомзоно было выборочным.  
 Пожалуйста <a href="http://www.nhplace.com/kent/contact-kent.html">сообщайте об ошибках</a>.
</p>

<p>
 <a href="http://www.nhplace.com/kent/Papers/sysdef.lisp">Нажмите здесь, чтобы загрузить копию самой
последней версии кода</a>
<br>
 --<i>KMP</i> 21-Jan-2001]
</p>

<pre>;;; -*- Mode: LISP; Syntax: ANSI-Common-Lisp; Package: (SYSDEF); -*-
;;;
;;; Copyright 2001 Kent M. Pitman.  All Rights Reserved.
;;; Portions Copyright 1984 Massachusetts Institute of Technology; used by permission.
;;;
;;; The intent is that sometime in the hopefully-near future this code will be released for 
;;; public use, but for now, while we are still debugging it, please talk to KMP before making 
;;; any serious dependencies on or modifications to this code.

(defpackage "SYSDEF"
  (:use "CL")
  (:import-from #.(package-name 
		   (or (find-package "CLOS")
		       (find-package "PCL")
		       (error "Can't find suitable CLOS package.")))
   ;; In CLISP, this is an internal symbol.  In other implementations,
   ;; this is an external symbol.  :import-from ignores that distinction.
   "CLASS-PRECEDENCE-LIST")
  (:export
   "CREATE-SYSTEM"
   "DEFINE-SYSTEM"
   "EXECUTE-ACTION"
   "EXECUTE-PLAN"
   "EXPLAIN-ACTION"
   "EXPLAIN-PLAN"
   "FIND-SYSTEM-NAMED"
   "FULL-NAME"
   "GENERATE-PLAN"
   "MODULAR-SYSTEM"
   "MODULE"
   "MODULE-ASSERTIONS"
   "MODULE-CAUSES"     
   "MODULE-NEEDS"
   "MODULE-SPEC"
   "MODULE-SYSTEM"
   "MODULES"
   "NAME"
   "PREPLANNED-SYSTEM"
   "PROCESS-OPTION"
   "PROCESS-OPTIONS"
   "SHORT-NAME"
   "SIMPLE-SYSTEM"
   "SOURCE-FILES"
   "SYSTEM"
   "SYSTEM-PLANS"
   "VANILLA-SYSTEM"
   ))

(in-package "SYSDEF")

<hr width="20%" align="left">
;;;; Общий протокол

(defgeneric name (entity))

<hr width="20%" align="left">
;;;; System

;;; SYSTEM
;;;
;;; Любой класс, который утверждает, что удовлетворяет протоколу SYSTEM должен использовать
;;; этот подклас в качестве суперкласса(родителя).

(defclass system () ())

;; Системный протокол (обобщенные функции)

(defgeneric short-name (system))
(defgeneric full-name  (system))

(defgeneric process-options (system options))
(defgeneric process-option (system option-key &amp;rest option-data))
(defgeneric source-files (system))
(defgeneric generate-plan (system plan-key &amp;rest plan-data))
(defgeneric explain-plan (system plan))
(defgeneric execute-plan (system plan))
(defgeneric explain-action (system action-key &amp;rest action-data))
(defgeneric execute-action (system action-key &amp;rest action-data))

;; Если у CL был бы способ объявить эти методы обязательными,
;; мы бы его использовали.  Вместо этого мы, по крайней мере делаем нечто лучшее,
;; сообщения об ошибках в качестве методов по умолчанию для класса протокола SYSTEM.
;; Обратите внимние, что мы не делаем это в классе T, так как некоторые обобщенные функции(generics)
;; имеют имена подобные NAME, которые могут использоваться в других пакетах
;; мы не можем предвидеть, поэтому мы сохраняем наши определения
;; локально для классов, которые мы создаем.

(defmethod name ((system system))
  (error "The required method NAME is not implemented by ~S."
	 system))

(defmethod short-name ((system system))
  (error "The required method SHORT-NAME is not implemented by ~S."
	 system))

(defmethod full-name ((system system))
  (error "The required method FULL-NAME is not implemented by ~S."
	 system))

(defmethod process-options ((system system) options)
  (error "The required method PROCESS-OPTIONS is not implemented by ~S."
	 system))

(defmethod process-option ((system system) option-name &amp;rest option-args)
  (error "The required method PROCESS-OPTION is not implemented by ~S."
	 system))

(defmethod source-files ((system system))
  (error "The required method SOURCE-FILES is not implemented by ~S."
	 system))

(defmethod generate-plan ((system system) plan-key &amp;rest plan-args)
  (error "The required method GENERATE-PLAN is not implemented by ~S."
	 system))

(defmethod explain-plan ((system system) plan)
  (error "The required method EXPLAIN-PLAN is not implemented by ~S."
	 system))

(defmethod execute-plan ((system system) plan)
  (error "The required method EXECUTE-PLAN is not implemented by ~S."
	 system))

(defmethod explain-action ((system system) action-name &amp;rest action-args)
  (error "The required method EXPLAIN-ACTION is not implemented by ~S."
	 system))

(defmethod execute-action ((system system) action-name &amp;rest action-args)
  (error "The required method EXECUTE-ACTION is not implemented by ~S."
	 system))

<hr width="20%" align="left">
;;;; Vanilla System

;;; VANILLA-SYSTEM
;;;
;;; vanilla system знает об именах и способах обработки опций 
;;; но не имеет интересных вариантов, котоыре она готова обработать
;;; сделать её полезным как что то, как создать экзепляр.

(defclass vanilla-system (system)
  ((short-name :initarg :short-name 
	       :accessor short-name
	       :initform nil)
   (full-name  :initarg :full-name
	       :accessor full-name
	       :initform nil)))

;;; (NAME vanilla-system)
;;;
;;; Возвращает имя системы
;;; Длинное имя предпочтительнее короткого имени, но оба доступны.

(defmethod name ((system vanilla-system))
  (or (full-name system) (short-name system)))

;;; (PRINT-OBJECT vanilla-system stream)
;;;
;;; Для удобства отладки,
;;; (PRIN1 mysys) печатает что то вроде: #&lt;SYSTEM "My System" 343324&gt;
;;; (PRINC mysys) печатает что то вроде: My System

(defmethod print-object ((system vanilla-system) stream)
  (let ((my-name (name system)))
    (if *print-escape*
	(print-unreadable-object (system stream :type t :identity t)
          (format stream "~S" my-name))
	(format stream "~A" my-name))))

;;; (DESCRIBE-OBJECT vanilla-system stream)
;;;
;;; Имеет ли эта часть объяснение уместное для класса.
;;; Другие классы, примешанные к данному должны использовать методы :AFTER или :BEFORE.

(defmethod describe-object ((system vanilla-system) stream)
  (with-slots (full-name short-name) system
    (format stream "~2&amp;~S:~%The system named ~A~@[, or ~A,~] is of class ~S.~%" 
	    system 
            full-name 
            (unless (equal full-name short-name) short-name)
            (class-of system))
    system))

<hr width="20%" align="left">
;;;; Средства работы с Опциями(Options Facility)

;;; (PROCESS-OPTIONS vanilla-system options)
;;;
;;; Отображение в соответствии с заданными параметрами(опциям) и их обработка.

(defmethod process-options ((system vanilla-system) options)
  (dolist (data options)
    (apply #'process-option system (car data) (cdr data)))
  system)

;;; (PROCESS-OPTION vanilla-system opt-name .  opt-args)
;;;
;;; :NAME Устанавливает значение по умолчанию для всех типов имен.
;;; :SHORT-NAME Устанавливает короткое имя (переопределяет :NAME, если оно задано).
;;; :LONG-NAME Устанавиливает длинное имя (переопределяет  :NAME, если оно задано).
;;; в противном случае сигнализирует об ошибке.

(defmethod process-option ((system vanilla-system) (key (eql :name)) &amp;rest data)
  (with-slots (short-name full-name) system
    (destructuring-bind (datum) data
      (if (not short-name) (setq short-name (string datum)))
      (if (not full-name)  (setq full-name  (string datum))))))

(defmethod process-option ((system vanilla-system) (key (eql :short-name)) &amp;rest data)
  (with-slots (short-name full-name) system
    (destructuring-bind (datum) data
      (setq short-name (string datum)))))

(defmethod process-option ((system vanilla-system) (key (eql :full-name)) &amp;rest data)
  (with-slots (short-name full-name) system
    (destructuring-bind (datum) data
      (setq full-name (string datum)))))

(defmethod process-option ((system vanilla-system) (key t) &amp;rest data)
  (error "The option ~S is not known to ~S.~%Data: ~S"
         key system data))

<hr width="20%" align="left">
;;;; Планирование/Выполннение Действий(Planning/Executing Actions)

;;; (GENERATE-PLAN vanilla-system action . data)
;;;
;;; Этот метод возвращает абстрактную информацию о том, как выполнить
;;; указанное действие(ACTION). Ответ выдается в форме списка
;;; ((ACTION-KEY .  ACTION-ARGS1) (ACTION-KEY .  ACTION-ARGS2) ...),
;;; такого, что выполнение EXECUTE-ACTION (или EXPLAIN-ACTION) для каждого 
;;; ACTION-KEY (с заданными аргументами ACTION-ARGS) к объекту в заданном порядке
;;; выполняет действие, о котором идет речь.
;;;
;;;  :UPDATE       Как компилировать (или по другому изменять) сисетму,
;;;  :INSTANTIATE  Как загружать (или по иному создавать работающую версию) систему.
;;;
;;;  В противном случае     возникает ошибка, если дейстивие не определено.
;;;                (Подклассы этого класса могут пердоставить дополнительные
;;;                ключи-действия(action-keys), если они также управляют EXECUTE-ACTION
;;;                и EXPLAIN-ACTION соответственно.)

(defmethod generate-plan ((system vanilla-system) (key t) &amp;rest data)
  (error "The object ~S does not know how to ~S.~
     ~%~@[Perhaps you want to use ~A instead?~
      ~%~]Data: ~S"
         system
         key
         (case key
           ((:load)    :instantiate)
           ((:compile) :update))
         data))

;;; (EXECUTE-PLAN vanilla-system plan)
;;;
;;; Шаги для выполнения плана.
;;;
;;; PLAN может быть именем плана (символом) или списком шагов
;;; таких как возврат из GENERATE-PLAN.

(defmethod execute-plan ((system vanilla-system) plan)
  (cond ((symbolp plan)
         (execute-plan system (generate-plan system plan)))
        (t
         (dolist (step plan)
           (apply #'execute-action system step))))
  system)

;;; (EXPLAIN-PLAN vanilla-system plan)
;;;
;;; Шаги объясняющие PLAN.
;;;
;;; PLAN может быть именем плана (символом) или списком шагов
;;; таких как возврат из GENERATE-PLAN.

(defmethod explain-plan ((system vanilla-system) plan)
  (cond ((symbolp plan)
         (explain-plan system (generate-plan system plan)))
        (t
         (dolist (step plan)
           (apply #'explain-action system step))))
  system)

;;; (EXECUTE-ACTION vanilla-system key .  data)
;;; (EXPLAIN-ACTION vanilla-system key .  data)
;;;
;;; EXECUTE-ACTION вызывает выполнение определенного действия.
;;;
;;; EXPLAIN-ACTION описывает, что быдут делать данное действие в случае его выполнения.
;;;
;;; Ключ действия должен быть одним из:
;;;  :LOAD      Загрузить файл (Lisp).
;;;  :COMPILE   Скомпилировать файл (Lisp).
;;;  В противном случае это ошибка.

(defmethod execute-action ((system vanilla-system) (key (eql :load)) &amp;rest data)
  (destructuring-bind (file) data
    (load file)))

(defmethod execute-action ((system vanilla-system) (key (eql :compile)) &amp;rest data)
  (destructuring-bind (file) data
    (compile-file file)))

(defmethod execute-action ((system vanilla-system) (key t) &amp;rest data)
  (error "The action ~S is not known to ~S.~%Data: ~S"
         key system data))

;;; (EXPLAIN-ACTION vanilla-system key . data)
;;;
;;; Если действие действительно, но описание не доступно, попробуем
;;; придумать правдоподобное описание на основе имени действия и его
;;; аргументов.

(defmethod explain-action ((system vanilla-system) (key t) &amp;rest data)
  (cond ((not 
          (let ((spec2 `(eql ,key)))
            (dolist (class (class-precedence-list (class-of system)))
              ;; FIND-METHOD works on the exact class with no inheritance,
              ;; so we must simulate inheritance dynamically.
              (if (find-method #'execute-action '() (list class spec2) nil)
                  (return t)))))
         (error "The action ~S is not known to ~S, so can't describe it.~%Data: ~S"
                key system data))
        (t (format t "~&amp;~A~@[ ~{~A~^, ~}.~]~%"
                   (string-capitalize key) data))))

<hr width="20%" align="left">
;;;; Простая Система(Simple System)

;;; SIMPLE-SYSTEM
;;;
;;; Простая система это система, которая имеет зависимость между файлами
;;; записанную(определяемую) слева на право.

(defclass simple-system (vanilla-system)
  ((source-files :initarg :source-files
                 :reader source-files
                 :initform '())))

;;; (DESCRIBE-OBJECT simple-system) :AFTER
;;;
;;; Указывает на некоторую информацию о файлах, которые составляют систему.

(defmethod describe-object :after ((system simple-system) stream)
  (format stream "~&amp;It has source files~{~&lt;~%~1:; ~A~&gt;~^,~}.~%" 
          (source-files system)))

;;; (PROCESS-OPTIONS simple-system options)
;;;
;;; Единственная опция, разрешенная для простой системы это список имён файлов
;;; упорядоченными по их зависимости слева на право.

(defmethod process-options ((system simple-system) options)
  (with-slots (source-files) system
    (when options
      (setq source-files '())
      (let ((default-pathname (merge-pathnames (car options))))
	(dolist (file options)
	  (setq default-pathname (merge-pathnames file default-pathname))
	  (push default-pathname source-files))
	(setq source-files (nreverse source-files)))
      t)))

;;; (GENERATE-PLAN simple-system :UPDATE)
;;;
;;; Чтобы обновить систему такого типа, нужно скомпилировать и загрузить каждый
;;; её файл в заданной последовательности.

(defmethod generate-plan ((system simple-system) (key (eql :update)) &amp;rest data)
  (mapcan #'(lambda (file)
              (list (list ':compile file)
                    (list ':load (compile-file-pathname file))))
          (source-files system)))

;;; (GENERATE-PLAN simple-system :INSTANTIATE)
;;;
;;; Чтобы создать работающий экземпляр такой системы надо просто загрузить
;;; какждый её файл в указанной последовательности.

(defmethod generate-plan ((system simple-system) (key (eql :instantiate)) &amp;rest data)
  (mapcan #'(lambda (file)
              (list (list ':load (make-pathname :type nil :defaults file))))
          (source-files system)))

<hr width="20%" align="left">
;;;; Pre-Planned System

;;; PREPLANNED-SYSTEM
;;;
;;; Запланированная система - это система, которая имеет план для управления
;;; указанный явно, а не выведенный из чего-либо.

(defclass preplanned-system (vanilla-system)
  ((source-files :initarg :files :accessor source-files :initform '() )
   (system-plans :initarg :plans                        :initform '() )))

;;; (PROCESS-OPTIONS preplanned-system options)
;;;
;;; Предложения(пункты) DEFINE-SYSTEM для этого типа системы
;;; это просто имя плана - команда (&lt;plan-name&gt; .  &lt;commands&gt;).

(defmethod process-options ((system preplanned-system) options)
  (with-slots (source-files system-plans) system
    (setq source-files (car options))
    (setq system-plans (cdr options))))

;;; (GENERATE-PLAN preplanned-system operation)
;;;
;;; Здесь выполняется простой поиск в таблице, чтобы найти план.

(defmethod generate-plan ((system preplanned-system) operation &amp;rest data)
  (check-type data null)
  (with-slots (system-plans) system
    (let ((entry (assoc operation system-plans)))
      (cond (entry (cdr entry))
            (t (error "No plan for operation ~S" operation))))))

<hr width="20%" align="left">
;;;; Модульная Система(Modular System)

;;; MODULAR-SYSTEM
;;;
;;; Модульная система позволяет указывать межмодульные зависимости,
;;; как явные, так и не явные.

(defclass modular-system (vanilla-system)
  ((modules :initarg :modules
            :accessor modules
            :initform '())))

;;; (DESCRIBE-SYSTEM modular-system stream) :AFTER
;;;
;;; Когда описывается модульная система, мы обращаем внимание на информацию
;;; говорящую, сколько у неё модулей, а затем мы просим каждый модуль
;;; описать себя.

(defmethod describe-system :after ((system modular-system) stream)
  (let* ((m-list (modules system)) (n (length m-list)))
    (format stream "~&amp;It has ~D module~:P~C~%"
	    n (if (= n 0) #\. #\:))
    (dolist (m m-list)
      (describe m))))

;;; (GET-MODULE modular-system name)
;;;
;;; Возвращает компонентный модуль с заданным именем (или NIL если его нет).

(defmethod get-module ((system modular-system) name)
  (dolist (m (modules system))
    (if (eq (name m) name) (return m))))

;;; (SOURCE-FILES modular-system)
;;;
;;; Возвращает список исходный файлов для системы.

(defmethod source-files ((system modular-system))
  (apply #'append (mapcar #'source-files (modules system))))

;;; (PROCESS-OPTION modular-system module .  spec)
;;;
;;; Объявляет как обрабатывать опцию :MODULE.  Создает объект
;;; типа MODULE и позволяет ему обрабатывать связанные с ним спецификации(spec).

(defmethod process-option ((system modular-system) (key (eql :module)) &amp;rest spec)
  (with-slots (modules) system
    (setq modules
          (nconc modules
                 (list (make-instance 'module
				      :system system
				      :spec spec))))))

<hr width="20%" align="left">
;;;; Модуль(Module)

;;; MODULE
;;;
;;; Модуль представляет собой набор файлов, которые будут использоваться как 
;;; единый строительный блок для модульной системы.

(defclass module ()
  ((name         :initarg :name         :accessor name              :initform nil)
   (system       :initarg :system       :accessor module-system     :initform nil)
   (spec         :initarg :spec         :accessor module-spec       :initform nil)
   (source-files :initarg :source-files :accessor source-files      :initform '())
   (assertions   :initarg :assertions   :accessor module-assertions :initform '())
   (needs        :initarg :needs        :accessor module-needs      :initform '())
   (causes       :initarg :causes       :accessor module-causes     :initform '())))

;;; (INITIALIZE-INSTANCE module &amp;key) :AFTER
;;;
;;; Смотрите за тем, чтобы если SPEC был задан, он обрабатывался соответствующим образом.

(defmethod initialize-instance :after ((module module) &amp;key)
  (process-spec module (module-spec module)))

;;; (PRINT-OBJECT module stream)
;;;
;;; Для удобства отладки.
;;; (PRIN1 mod) печатает что то типа: #&lt;Module MYSYS*MOD1 234567&gt;
;;; (PRINC mod) печатает что то типа: MOD1

(defmethod print-object ((module module) stream)
  (with-slots (name system) module
    (if *print-escape*
	(print-unreadable-object (module stream :type t :identity t)
	  (format stream "~@[~A*~]~:[Anonymous~;~:*~A~]"
		  (if system (short-name system))
		  name))
      (format stream "~A" name))))

;;; (DESCRIBE-OBJECT module stream)
;;;
;;; Подробности о исходных файлах и информация о зависимостях
;;; для модуля.

(defmethod describe-object ((module module) stream)
  (with-slots (needs source-files system) module
    (format stream "~2&amp; ~A~@[  ~{~%~A~^.~}~]~%" module source-files)
    (do ((n needs (cddr n)))
        ((null n))
      (format t "~&amp; ~S dependenc~@P: ~{~S~^, ~}.~%"
              (car n) (length (cadr n)) (cadr n)))
    (format t "~&amp;")
    system))

;;; (PROCESS-SPEC module spec)
;;;
;;; Обрабатывает данный SPEC впитывая соответствующую информацию.
;;;
;;; NAME принимается только в том случае, если информация об имени еще не настроена.
;;; Это потому, что :PROCESS-SPEC может быть рекурсивно вызван для других списков
;;; утверждений, если есть включенные модули со своими спецификациями.
;;; В этом случае, мы хотим принять их атрибуты, но не их имена.
;;;
;;; Утверждения(ASSERTIONS) обрабатываются следующими, потому что они, вероятно, указывают
;;; предварительные условия для этого модуля и любых файлов, которые ему нужны для загрузки,
;;; получить настройки прежде чем мы настроим файлы для этого модуля.
;;;
;;; Наконец, файлы(FILES) связанные с этим модулем обрабатываются.

(defmethod process-spec ((module module) s)
  (with-slots (name) module
    (when s
      (if (not name) (setq name (car s)))
      (process-assertions module (cddr s))
      (process-files module (cadr s)))))

;;; (PROCESS-FILES module files-list)
;;;
;;; Добавляет информацию о файле, указанную в списке файлов(FILES-LIST) в основной список FILES.

(defmethod process-files ((module module) files-list)
  (with-slots (source-files system) module
    (if (atom files-list) (setq files-list (list files-list)))
    (dolist (file files-list)
      (cond ((typep file 'pathname)
	     (setq source-files (nconc source-files (list file))))
	    ((stringp file)
	     (setq source-files (nconc source-files (list (parse-namestring file)))))
	    ((symbolp file)
	     (process-spec system (module-spec (get-module system file))))
	    (t
	     (error "Bad object in file list: ~S - ~S" file system))))))

;;; (PROCESS-ASSERTIONS module spec)
;;;
;;; Перебирает утверждения(assertions), обрабатывая каждое.

(defmethod process-assertions ((module module) assertion-list)
  (dolist (assertion assertion-list)
    (apply #'process-assertion (module-system module) assertion)))

;;; (PROCESS-ASSERTION module key . data)
;;;
;;; Этот медот используется для обработки утверждений(assertions) о зависимостях, и т.д.
;;; для данного модуля.
;;;
;;; Далее распределяется в зависимости от ключа:
;;;
;;;  :NEEDS     Объявляет необходимость создания экземпляров модулей в определенное время.
;;;  :CAUSES    Объявляет утверждения, которые будут немедленно направлены потребителю.
;;;  В противном случае ошибка.

(defmethod process-assertion ((module module) (key (eql :needs)) &amp;rest data)
  (with-slots (needs) module
    (dolist (item data)
      (let ((marker (car item)))
        (dolist (module-name (cdr item))
          (when (not (member module-name (getf needs marker)))
            (let ((m (get-module (module-system module) module-name)))
              ;; This may be overly conservative, but will work...
              (process-assertions module (module-causes m))
              (setf (getf needs marker)
                    (nconc (getf needs marker) (list module-name))))))))))

(defmethod process-assertion ((module module) (key (eql :causes)) &amp;rest data)
  ;; Filtering this is technically unnecessary, but it will keep
  ;; redefinition from swamping us.
  (with-slots (causes) module
    (dolist (item data)
      (if (not (member item causes :test #'equal))
          (setf causes (nconc causes (list item)))))))

(defmethod process-assertion ((module module) (key t) &amp;rest data)
  (error "The ~S assertion is not known to ~S.~%Data: ~S"
         key module data))

<hr width="20%" align="left">
;;;; Пользовательский Интерфейс(User Interface)

;;; (CREATE-SYSTEM name type [options])
;;;
;;; Создает объект системы данного типа(TYPE), инициализируя его с данным
;;; именем(NAME) и опциями(OPTIONS). Возвращает созданный объект без постоянного
;;; сохранения его где бы то нибыло.

(defun create-system (name class &amp;optional options)
  (let ((system (make-instance class)))
    (process-option  system :name name)
    (process-options system options)
    system))

;;; (FIND-SYSTEM name)
;;;
;;; Получает определение некоторого глобально определенного объекта системы.

(defun find-system-named (system-name &amp;optional (errorp t))
  (etypecase system-name
    (system system-name)
    (symbol (or (get system-name 'system)
                (if errorp
                    (error "System not found: ~S" system-name)
                  nil)))))

(defun (setf find-system-named) (new-system system-spec) 
  (let ((system-name (etypecase system-spec
                       (symbol system-spec)
                       (system (name system-spec)))))
    (setf (get system-name 'system) new-system)))

;;; (DEFINE-SYSTEM name type .  options)
;;;
;;; Создает и инициализирует систему с заданным именем.
;;; Сохраняет определение глобально для последующего доступа.

(defmacro define-system (name type &amp;body data)
  (check-type name symbol "a packaged symbol naming the system to be defined")
  `(setf (find-system-named ',name)
         (create-system ',name ',type ',data)))

</pre>

<hr>

<hr>

<p>
Original printed text document<br>
<b>Copyright © 1984 Massachusetts Institute of Technology.</b>
<br>
</p>

<p>
Republished on the web by Kent M. Pitman with appropriate permission.
</p>

<p>
HTML hypertext version of document<br>
<b>Copyright © 2001 Kent M. Pitman.  All rights reserved.</b><br>
The following limited, non-exclusive, 
revokable licenses are granted:
</p>

<blockquote>
<p>
Browsing of this document (that is, transmission and display of a temporary
copy of this document for the ordinary purpose of direct viewing by a 
human being in the usual manner that hypertext browsers permit such
viewing) is expressly permitted, provided that no recopying, 
redistribution, redisplay, or retransmission is made of any such copy.
</p>

<p>
Bookmarking of this document (that is, recording only the document's title and 
Uniform Resource Locator, or URL, but not its content,
for the purpose of remembering an association between the document's title
and the URL, and/or for the purpose of making a subsequent request 
for a fresh copy of the content named by that URL)
is also expressly permitted.
</p>
</blockquote>

<p>
All other uses require negotiated permission.
</p>

</font>

<hr>

<p align="center">
<a href="http://www.nhplace.com/kent/Papers/index.html"><i>Click here for an index 
of other titles by Kent Pitman.</i></a>
</p>

</body></html>